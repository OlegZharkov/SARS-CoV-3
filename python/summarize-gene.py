"""
Summarize HyPhy selection analyses for a gene from JSON files

    SLAC (required)
    FEL  (required)
    MEME (required)
    PRIME (optional)

Author:
    Sergei L Kosakovsky Pond (spond@temple.edu)

Version:
    v0.0.1 (2020-03-23)


"""

import argparse
import sys
import json
import re
import datetime
import os
import math, csv
from   os import  path
import operator
import collections 
import BioExt
import compress_json
from   Bio import SeqIO

from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
#from Bio.Alphabet import IUPAC
from BioExt.uds import _align_par
from BioExt.scorematrices import (
    DNAScoreMatrix,
    FrequenciesError,
    ProteinScoreMatrix
    )


sys.setrecursionlimit(10**6) 
arguments = argparse.ArgumentParser(description='Summarize selection analysis results.')

arguments.add_argument('-o', '--output', help = 'Write results here', type = argparse.FileType('w'), default = sys.stdout)
arguments.add_argument('-s', '--slac',   help = 'SLAC results file', required = True, type = str)
arguments.add_argument('-f', '--fel',   help = 'FEL results file', required = True, type = str)
arguments.add_argument('-m', '--meme',   help = 'MEME results file', required = True, type = str)
arguments.add_argument('-p', '--prime',  help = 'PRIME results file', required = False, type = str)
arguments.add_argument('-u', '--fubar',  help = 'FUBAR results file', required = False, type = str)
arguments.add_argument('--map',  help = 'IDs that EPI accession numbers correspond to', required = True, type = str)
arguments.add_argument('-P', '--pvalue',  help = 'p-value', required = False, type = float, default = 0.1)
arguments.add_argument('-c', '--coordinates',  help = 'An alignment with reference sequence (assumed to start with NC)', required = True, type = argparse.FileType('r'))

arguments.add_argument('-T', '--epitopes',  help = 'If provided, an epitope map in a JSON format', required = False, type = str)
arguments.add_argument('-D', '--database', help ='Obfuscated database JSON', required = True, type = str)
arguments.add_argument('-d', '--duplicates', help ='The JSON file recording compressed sequence duplicates', required = True, type = str)
arguments.add_argument('-M', '--MAF', help ='Also include sites with hapoltype MAF >= this frequency', required = False, type = float, default = 0.2)
arguments.add_argument('-E', '--evolutionary_annotation', help ='If provided use evolutionary likelihood annotation', required = False, type = str)
arguments.add_argument('-F', '--evolutionary_fragment', help ='Used in conjunction with evolutionary annotation to designate the fragment to look up', required = False, type = str)
arguments.add_argument('--fragment_shift', help ='Used in conjunction with evolutionary annotation to designate the fragment offset to look up', required = False, type = int, default = 0)
arguments.add_argument('-A', '--mafs', help ='If provided, write a CSV file with MAF/p-value tables', required = False, type = str)
arguments.add_argument('-V', '--evolutionary_csv', help ='If provided, write a CSV file with observed/predicted frequncies', required = False, type = str)
arguments.add_argument('-O', '--overall', help ='If provided, write site annotations to this JSON', required = False, type = str)
arguments.add_argument('-S', '--offset',  help ='Nucleotide position of the start of this gene in terms of reference genome', required = False, type = int, default = 0)
arguments.add_argument('--frame_shift', help = 'Used in conjunction with annotation; is set, add this value to genome coordinates', required = False, type = int, default = 0)
#arguments.add_argument('-V', '--variants', help ='If provided, write JSON-like VCF to this file', required = False, type = str)

###### SOME HELPER FUNCTIONS HERE

def traverse_tree_in_order (node, labels, slac_data, i, parent_tag, root):
    node_tag = None
    nn = root if node["name"] == 'root' else node["name"]
    if nn in slac_data:
        node_tag = slac_data[nn]["codon"][0][i]
        #print (node_tag, parent_tag)
        if (parent_tag != node_tag):
            labels [nn] = node_tag
            labels[node["name"]] = node_tag
    else:
        print ("Not in %s" % nn)
        
    if "children" in node:
        for c in node["children"]:
            traverse_tree_in_order (c, labels, slac_data,i, node_tag, root)
                    
                    
def sequence_to_accession (name):
    #epi_isl_466783_British_Columbia_20200401_null_1
    if name[0:2] == "NC":
        return "EPI_ISL_402125"
    parts = name.upper().split ("_")
    if len (parts) >= 3:
        
            for p in ('epi','EPI'):
                try: 
                    i = parts.index (p)
                    if i >= 0:
                        return "_".join (parts[i:i+3])
                except:
                    pass
    #print (name, parts, file = sys.stderr)
    return None

def newick_parser(nwk_str, bootstrap_values):
    clade_stack = []
    automaton_state = 0
    current_node_name = ""
    current_node_attribute = ""
    current_node_annotation = ""
    quote_delimiter = None
    name_quotes = {
      "'": 1,
      '"': 1
    }
    
    def add_new_tree_level():
      new_level = {
        "name": None
      };
      the_parent = clade_stack[len(clade_stack) - 1]
      if (not "children" in the_parent):
        the_parent["children"] = [];
      
      clade_stack.append (new_level);
      the_parent["children"].append(clade_stack[len(clade_stack) - 1]);
      clade_stack[len(clade_stack)-1]["original_child_order"] = len(the_parent["children"])
    

    def finish_node_definition():
      nonlocal current_node_name
      nonlocal current_node_annotation
      nonlocal current_node_attribute
      
      this_node = clade_stack.pop()
      if (bootstrap_values and "children" in this_node):
        this_node["bootstrap_values"] = current_node_name
      else:
        this_node["name"] = current_node_name
      
      this_node["attribute"] = current_node_attribute
      this_node["annotation"] = current_node_annotation
      current_node_name = ""
      current_node_attribute = ""
      current_node_annotation = ""
    

    def generate_error(location):
      return {
        'json': None,
        'error':
          "Unexpected '" +
          nwk_str[location] +
          "' in '" +
          nwk_str[location - 20 : location + 1] +
          "[ERROR HERE]" +
          nwk_str[location + 1 : location + 20] +
          "'"
      }


    tree_json = {
      "name" : "root"
    }
    
    clade_stack.append(tree_json);

    space = re.compile("\s")

    for char_index in range (len(nwk_str)):
      try:
        current_char = nwk_str[char_index]
        if automaton_state == 0:
           #look for the first opening parenthesis
           if (current_char == "("):
              add_new_tree_level()
              automaton_state = 1
        elif automaton_state == 1 or automaton_state == 3:
            #case 1: // name
            #case 3: { // branch length
            #reading name
            if (current_char == ":"):
              automaton_state = 3;
            elif current_char == "," or current_char == ")":
              try:
                finish_node_definition()
                automaton_state = 1
                if (current_char == ","):
                  add_new_tree_level()
              except Exception as e:
                return generate_error(char_index)
              
            elif (current_char == "("):
              if len(current_node_name) > 0:
                return generate_error(char_index);
              else:
                add_new_tree_level()
              
            elif (current_char in name_quotes):
              if automaton_state == 1 and len(current_node_name) == 0 and len (current_node_attribute) == 0 and len (current_node_annotation) == 0:
                automaton_state = 2
                quote_delimiter = current_char
                continue
              return generate_error(char_index)
            else:
              if (current_char == "["):
                if len (current_node_annotation):
                  return generate_error(char_index)
                else:
                  automaton_state = 4
              else:
                if (automaton_state == 3):
                  current_node_attribute += current_char;
                else:
                  if (space.search(current_char)):
                    continue;
                  if (current_char == ";"):
                    char_index = len(nwk_str)
                    break
                  current_node_name += current_char;
        elif automaton_state == 2: 
            # inside a quoted expression
            if (current_char == quote_delimiter):
              if (char_index < len (nwk_str - 1)):
                if (nwk_str[char_index + 1] == quote_delimiter):
                  char_index+=1
                  current_node_name += quote_delimiter;
                  continue;

              quote_delimiter = 0
              automaton_state = 1
              continue
            else:
              current_node_name += current_char;
        elif automaton_state == 4:
           ##inside a comment / attribute
            if (current_char == "]"):
              automaton_state = 3
            else:
              if (current_char == "["):
                return generate_error(char_index);
              current_node_annotation += current_char;
      except Exception as e:
        return generate_error(char_index);

    if (len (clade_stack) != 1):
      return generate_error(len (nwk_str) - 1);

    if (len (current_node_name)):
        tree_json['name'] = current_node_name;

    return {
      'json': tree_json,
      'error': None
    }
    
    
def get_newick (root, names, lengths):
    element_array = []
    def node_display (n):
      if "children" in n:
        element_array.append ("(")
        for i, c in enumerate (n["children"]):
            if i:
                element_array.append (",")
            node_display (c)
        element_array.append (")")
      if n["name"] != 'root':
        element_array.append ("%s:%.2g" % (names[n["name"]], lengths[n["name"]]))
        
    node_display(root)
    return "".join (element_array)
 
def compress_array (array):
    unique_values = {}
    try:
        for v in array:
            if v not in unique_values:
                unique_values[v] = len (unique_values)

        #print (unique_values, file = sys.stderr)

        if len (unique_values) * 4 < len (array):
            lookup = {}
            for k, v in unique_values.items():
                lookup[v] = k
            compact_array = {'keys' : lookup, 'values' : []}
            for a in array:
                compact_array ['values'].append (unique_values[a])

            return compact_array

        return array

    except Exception as e:
        #raise (e)
        return array
        
        
def rle_compress (array):
    #print (array)
    if len (array) > 2:
        r = []
        checkpoint = 0
        last = array[0]
        array.append (-1) # sentinel
        for i in range (1, len (array)):
            if array[i] == last + 1:
                last += 1
            else:
                span = i - checkpoint 
                if span > 2:
                    r.append ('%d:%d' % (array[checkpoint], array[i-1]))
                else:
                    if span == 1:
                        r.append (array[i-1])
                    else:
                        r.append (array[i-2])
                        r.append (array[i-1])
                last = array[i]
                checkpoint = i
        print ("%d->%g" % (len (array)-1, len (r)/(len (array) - 1.)))
        return r
    return array
   
def load_json_or_compressed (file_name):
    if file_name.find (".json") + 5 == len(file_name):
        with open (file_name, "r") as file_object:
            return json.load (file_object)
    else:
        return compress_json.load (file_name)

###### END HELPER FUNCTIONS   

 

import_settings = arguments.parse_args()

db = load_json_or_compressed (import_settings.database)
dups = load_json_or_compressed (import_settings.duplicates)

date_parse_format = ["%Y%m%d","%Y-%m-%d"]

def parse_date_string (date_string):
	for f in date_parse_format:
	     try:
	         return datetime.datetime.strptime (date_string,f)
	     except:
	     	pass
	raise Exception ("Failed to parse " % date_string)


sequences_with_dates = {}
sequences_with_locations = {}
country_to_sub = {}

def get_location (v):
    if 'country' in v['location']:
        country_to_sub[v['location']['country']] = v['location']['subregion']
        return v['location']['country']
    if 'subregion' in v['location']:
        country_to_sub[v['location']['subregion']] = v['location']['subregion']
        return v['location']['subregion']
    return None


accession_mapper = {}
for i, id in enumerate (load_json_or_compressed (import_settings.map)):
    accession_mapper [id.upper()] = i
    

now      = datetime.datetime.now()
min_date = now
max_date = datetime.datetime (1900,1,1)

for id, record in db.items():
    try:
        date_check =  parse_date_string (record['collected'])
        if date_check.year < 2019 or date_check.year == 2019 and date_check.month < 10 or date_check >= now: 
            continue
        if date_check < min_date:
            min_date = date_check
        if date_check > max_date:
            max_date = date_check
        sequences_with_dates[id] = record['collected']
        sequences_with_locations[id] = get_location (record)
    except Exception as e:
        pass
        
date_dups     = {}

maf_writer = None

if import_settings.mafs:
    try:
        maf_file = open (import_settings.mafs, "r+")
        maf_writer = csv.writer (maf_file)
        maf_file.seek (0,2)
    except FileNotFoundError as fnf:
        maf_file = open (import_settings.mafs, "w")
        maf_writer = csv.writer (maf_file)
        maf_writer.writerow (["Gene","Site","aa","count","freq","total"])
    
evo_writer = None  




if import_settings.evolutionary_csv:
    try:
        evo_file = open (import_settings.evolutionary_csv, "r+")
        evo_writer = csv.writer (evo_file)
        evo_file.seek (0,2)
    except FileNotFoundError as fnf:
        evo_file = open (import_settings.evolutionary_csv, "w")
        evo_writer = csv.writer (evo_file)
        evo_writer.writerow (["Gene","Site","Codon","Count","Observed","Predicted","Mostlikely"])
        

evo_annotation = None

if import_settings.evolutionary_annotation:
    evo_annotation = load_json_or_compressed (import_settings.evolutionary_annotation)
    if import_settings.evolutionary_fragment not in evo_annotation:
        evo_annotation = None
    else:
        evo_annotation = evo_annotation[import_settings.evolutionary_fragment]

annotation_json = None

if (import_settings.overall):
    try:
      annotation_json = load_json_or_compressed (import_settings.overall)
    except FileNotFoundError as fnf:
        annotation_json = {}
        
mapped_dups = {}

def extract_isl_id (seq_id):
    parts = seq_id.upper().split ('_')
    epi = parts.index ('EPI')
    return 'epi_isl_' + parts[epi+2]    


for seq, copies in dups.items():
    date_collection = {}
    location_collection = []
    accessions = []
    
    for cp in copies.values():
        try:
            accessions.append (accession_mapper [sequence_to_accession (cp)])
        except KeyError as e:
            pass
        cpv = extract_isl_id (cp)
        if cpv in sequences_with_dates:
            cdate = sequences_with_dates[cpv]
            location = sequences_with_locations[cpv]
            
            tag = (cdate, location)
 
            if not tag in date_collection:
                date_collection[tag] = 1
            else:
                date_collection[tag] += 1
            
    try:
           mapped_dups [accession_mapper [sequence_to_accession (seq)]] = rle_compress(sorted(accessions))
    except KeyError as e:
        if len (accessions):
            accession_mapper [sequence_to_accession (seq)] = accessions[0]
            mapped_dups[accessions[0]] = rle_compress(sorted(accessions))
        else:
            accession_mapper [sequence_to_accession (seq)] = -1
            mapped_dups [-1] = []
            
    date_dups[seq] = date_collection   
  
slac = load_json_or_compressed (import_settings.slac)
fel  = load_json_or_compressed (import_settings.fel)
meme = load_json_or_compressed (import_settings.meme)


if import_settings.prime:
    prime  = load_json_or_compressed (import_settings.prime)
else:
    prime = None

if import_settings.fubar:
    fubar  = load_json_or_compressed (import_settings.fubar)
else:
    fubar = None


if import_settings.epitopes:
    epitopes  = load_json_or_compressed (import_settings.epitopes)
else:
    epitopes = None

    
ref_seq_map = None
score_matrix_ = BioExt.scorematrices.DNA95.load()
score_matrix_codon = BioExt.scorematrices.HIV_BETWEEN_F.load()

ref_genes       = [
    ['genome', 'ATTAAAGGTTTATACCTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAAAATCTGTGTGGCTGTCACTCGGCTGCATGCTTAGTGCACTCACGCAGTATAATTAATAACTAATTACTGTCGTTGACAGGACACGAGTAACTCGTCTATCTTCTGCAGGCTGCTTACGGTTTCGTCCGTGTTGCAGCCGATCATCAGCACATCTAGGTTTCGTCCGGGTGTGACCGAAAGGTAAGATGGAGAGCCTTGTCCCTGGTTTCAACGAGAAAACACACGTCCAACTCAGTTTGCCTGTTTTACAGGTTCGCGACGTGCTCGTACGTGGCTTTGGAGACTCCGTGGAGGAGGTCTTATCAGAGGCACGTCAACATCTTAAAGATGGCACTTGTGGCTTAGTAGAAGTTGAAAAAGGCGTTTTGCCTCAACTTGAACAGCCCTATGTGTTCATCAAACGTTCGGATGCTCGAACTGCACCTCATGGTCATGTTATGGTTGAGCTGGTAGCAGAACTCGAAGGCATTCAGTACGGTCGTAGTGGTGAGACACTTGGTGTCCTTGTCCCTCATGTGGGCGAAATACCAGTGGCTTACCGCAAGGTTCTTCTTCGTAAGAACGGTAATAAAGGAGCTGGTGGCCATAGTTACGGCGCCGATCTAAAGTCATTTGACTTAGGCGACGAGCTTGGCACTGATCCTTATGAAGATTTTCAAGAAAACTGGAACACTAAACATAGCAGTGGTGTTACCCGTGAACTCATGCGTGAGCTTAACGGAGGGGCATACACTCGCTATGTCGATAACAACTTCTGTGGCCCTGATGGCTACCCTCTTGAGTGCATTAAAGACCTTCTAGCACGTGCTGGTAAAGCTTCATGCACTTTGTCCGAACAACTGGACTTTATTGACACTAAGAGGGGTGTATACTGCTGCCGTGAACATGAGCATGAAATTGCTTGGTACACGGAACGTTCTGAAAAGAGCTATGAATTGCAGACACCTTTTGAAATTAAATTGGCAAAGAAATTTGACACCTTCAATGGGGAATGTCCAAATTTTGTATTTCCCTTAAATTCCATAATCAAGACTATTCAACCAAGGGTTGAAAAGAAAAAGCTTGATGGCTTTATGGGTAGAATTCGATCTGTCTATCCAGTTGCGTCACCAAATGAATGCAACCAAATGTGCCTTTCAACTCTCATGAAGTGTGATCATTGTGGTGAAACTTCATGGCAGACGGGCGATTTTGTTAAAGCCACTTGCGAATTTTGTGGCACTGAGAATTTGACTAAAGAAGGTGCCACTACTTGTGGTTACTTACCCCAAAATGCTGTTGTTAAAATTTATTGTCCAGCATGTCACAATTCAGAAGTAGGACCTGAGCATAGTCTTGCCGAATACCATAATGAATCTGGCTTGAAAACCATTCTTCGTAAGGGTGGTCGCACTATTGCCTTTGGAGGCTGTGTGTTCTCTTATGTTGGTTGCCATAACAAGTGTGCCTATTGGGTTCCACGTGCTAGCGCTAACATAGGTTGTAACCATACAGGTGTTGTTGGAGAAGGTTCCGAAGGTCTTAATGACAACCTTCTTGAAATACTCCAAAAAGAGAAAGTCAACATCAATATTGTTGGTGACTTTAAACTTAATGAAGAGATCGCCATTATTTTGGCATCTTTTTCTGCTTCCACAAGTGCTTTTGTGGAAACTGTGAAAGGTTTGGATTATAAAGCATTCAAACAAATTGTTGAATCCTGTGGTAATTTTAAAGTTACAAAAGGAAAAGCTAAAAAAGGTGCCTGGAATATTGGTGAACAGAAATCAATACTGAGTCCTCTTTATGCATTTGCATCAGAGGCTGCTCGTGTTGTACGATCAATTTTCTCCCGCACTCTTGAAACTGCTCAAAATTCTGTGCGTGTTTTACAGAAGGCCGCTATAACAATACTAGATGGAATTTCACAGTATTCACTGAGACTCATTGATGCTATGATGTTCACATCTGATTTGGCTACTAACAATCTAGTTGTAATGGCCTACATTACAGGTGGTGTTGTTCAGTTGACTTCGCAGTGGCTAACTAACATCTTTGGCACTGTTTATGAAAAACTCAAACCCGTCCTTGATTGGCTTGAAGAGAAGTTTAAGGAAGGTGTAGAGTTTCTTAGAGACGGTTGGGAAATTGTTAAATTTATCTCAACCTGTGCTTGTGAAATTGTCGGTGGACAAATTGTCACCTGTGCAAAGGAAATTAAGGAGAGTGTTCAGACATTCTTTAAGCTTGTAAATAAATTTTTGGCTTTGTGTGCTGACTCTATCATTATTGGTGGAGCTAAACTTAAAGCCTTGAATTTAGGTGAAACATTTGTCACGCACTCAAAGGGATTGTACAGAAAGTGTGTTAAATCCAGAGAAGAAACTGGCCTACTCATGCCTCTAAAAGCCCCAAAAGAAATTATCTTCTTAGAGGGAGAAACACTTCCCACAGAAGTGTTAACAGAGGAAGTTGTCTTGAAAACTGGTGATTTACAACCATTAGAACAACCTACTAGTGAAGCTGTTGAAGCTCCATTGGTTGGTACACCAGTTTGTATTAACGGGCTTATGTTGCTCGAAATCAAAGACACAGAAAAGTACTGTGCCCTTGCACCTAATATGATGGTAACAAACAATACCTTCACACTCAAAGGCGGTGCACCAACAAAGGTTACTTTTGGTGATGACACTGTGATAGAAGTGCAAGGTTACAAGAGTGTGAATATCACTTTTGAACTTGATGAAAGGATTGATAAAGTACTTAATGAGAAGTGCTCTGCCTATACAGTTGAACTCGGTACAGAAGTAAATGAGTTCGCCTGTGTTGTGGCAGATGCTGTCATAAAAACTTTGCAACCAGTATCTGAATTACTTACACCACTGGGCATTGATTTAGATGAGTGGAGTATGGCTACATACTACTTATTTGATGAGTCTGGTGAGTTTAAATTGGCTTCACATATGTATTGTTCTTTCTACCCTCCAGATGAGGATGAAGAAGAAGGTGATTGTGAAGAAGAAGAGTTTGAGCCATCAACTCAATATGAGTATGGTACTGAAGATGATTACCAAGGTAAACCTTTGGAATTTGGTGCCACTTCTGCTGCTCTTCAACCTGAAGAAGAGCAAGAAGAAGATTGGTTAGATGATGATAGTCAACAAACTGTTGGTCAACAAGACGGCAGTGAGGACAATCAGACAACTACTATTCAAACAATTGTTGAGGTTCAACCTCAATTAGAGATGGAACTTACACCAGTTGTTCAGACTATTGAAGTGAATAGTTTTAGTGGTTATTTAAAACTTACTGACAATGTATACATTAAAAATGCAGACATTGTGGAAGAAGCTAAAAAGGTAAAACCAACAGTGGTTGTTAATGCAGCCAATGTTTACCTTAAACATGGAGGAGGTGTTGCAGGAGCCTTAAATAAGGCTACTAACAATGCCATGCAAGTTGAATCTGATGATTACATAGCTACTAATGGACCACTTAAAGTGGGTGGTAGTTGTGTTTTAAGCGGACACAATCTTGCTAAACACTGTCTTCATGTTGTCGGCCCAAATGTTAACAAAGGTGAAGACATTCAACTTCTTAAGAGTGCTTATGAAAATTTTAATCAGCACGAAGTTCTACTTGCACCATTATTATCAGCTGGTATTTTTGGTGCTGACCCTATACATTCTTTAAGAGTTTGTGTAGATACTGTTCGCACAAATGTCTACTTAGCTGTCTTTGATAAAAATCTCTATGACAAACTTGTTTCAAGCTTTTTGGAAATGAAGAGTGAAAAGCAAGTTGAACAAAAGATCGCTGAGATTCCTAAAGAGGAAGTTAAGCCATTTATAACTGAAAGTAAACCTTCAGTTGAACAGAGAAAACAAGATGATAAGAAAATCAAAGCTTGTGTTGAAGAAGTTACAACAACTCTGGAAGAAACTAAGTTCCTCACAGAAAACTTGTTACTTTATATTGACATTAATGGCAATCTTCATCCAGATTCTGCCACTCTTGTTAGTGACATTGACATCACTTTCTTAAAGAAAGATGCTCCATATATAGTGGGTGATGTTGTTCAAGAGGGTGTTTTAACTGCTGTGGTTATACCTACTAAAAAGGCTGGTGGCACTACTGAAATGCTAGCGAAAGCTTTGAGAAAAGTGCCAACAGACAATTATATAACCACTTACCCGGGTCAGGGTTTAAATGGTTACACTGTAGAGGAGGCAAAGACAGTGCTTAAAAAGTGTAAAAGTGCCTTTTACATTCTACCATCTATTATCTCTAATGAGAAGCAAGAAATTCTTGGAACTGTTTCTTGGAATTTGCGAGAAATGCTTGCACATGCAGAAGAAACACGCAAATTAATGCCTGTCTGTGTGGAAACTAAAGCCATAGTTTCAACTATACAGCGTAAATATAAGGGTATTAAAATACAAGAGGGTGTGGTTGATTATGGTGCTAGATTTTACTTTTACACCAGTAAAACAACTGTAGCGTCACTTATCAACACACTTAACGATCTAAATGAAACTCTTGTTACAATGCCACTTGGCTATGTAACACATGGCTTAAATTTGGAAGAAGCTGCTCGGTATATGAGATCTCTCAAAGTGCCAGCTACAGTTTCTGTTTCTTCACCTGATGCTGTTACAGCGTATAATGGTTATCTTACTTCTTCTTCTAAAACACCTGAAGAACATTTTATTGAAACCATCTCACTTGCTGGTTCCTATAAAGATTGGTCCTATTCTGGACAATCTACACAACTAGGTATAGAATTTCTTAAGAGAGGTGATAAAAGTGTATATTACACTAGTAATCCTACCACATTCCACCTAGATGGTGAAGTTATCACCTTTGACAATCTTAAGACACTTCTTTCTTTGAGAGAAGTGAGGACTATTAAGGTGTTTACAACAGTAGACAACATTAACCTCCACACGCAAGTTGTGGACATGTCAATGACATATGGACAACAGTTTGGTCCAACTTATTTGGATGGAGCTGATGTTACTAAAATAAAACCTCATAATTCACATGAAGGTAAAACATTTTATGTTTTACCTAATGATGACACTCTACGTGTTGAGGCTTTTGAGTACTACCACACAACTGATCCTAGTTTTCTGGGTAGGTACATGTCAGCATTAAATCACACTAAAAAGTGGAAATACCCACAAGTTAATGGTTTAACTTCTATTAAATGGGCAGATAACAACTGTTATCTTGCCACTGCATTGTTAACACTCCAACAAATAGAGTTGAAGTTTAATCCACCTGCTCTACAAGATGCTTATTACAGAGCAAGGGCTGGTGAAGCTGCTAACTTTTGTGCACTTATCTTAGCCTACTGTAATAAGACAGTAGGTGAGTTAGGTGATGTTAGAGAAACAATGAGTTACTTGTTTCAACATGCCAATTTAGATTCTTGCAAAAGAGTCTTGAACGTGGTGTGTAAAACTTGTGGACAACAGCAGACAACCCTTAAGGGTGTAGAAGCTGTTATGTACATGGGCACACTTTCTTATGAACAATTTAAGAAAGGTGTTCAGATACCTTGTACGTGTGGTAAACAAGCTACAAAATATCTAGTACAACAGGAGTCACCTTTTGTTATGATGTCAGCACCACCTGCTCAGTATGAACTTAAGCATGGTACATTTACTTGTGCTAGTGAGTACACTGGTAATTACCAGTGTGGTCACTATAAACATATAACTTCTAAAGAAACTTTGTATTGCATAGACGGTGCTTTACTTACAAAGTCCTCAGAATACAAAGGTCCTATTACGGATGTTTTCTACAAAGAAAACAGTTACACAACAACCATAAAACCAGTTACTTATAAATTGGATGGTGTTGTTTGTACAGAAATTGACCCTAAGTTGGACAATTATTATAAGAAAGACAATTCTTATTTCACAGAGCAACCAATTGATCTTGTACCAAACCAACCATATCCAAACGCAAGCTTCGATAATTTTAAGTTTGTATGTGATAATATCAAATTTGCTGATGATTTAAACCAGTTAACTGGTTATAAGAAACCTGCTTCAAGAGAGCTTAAAGTTACATTTTTCCCTGACTTAAATGGTGATGTGGTGGCTATTGATTATAAACACTACACACCCTCTTTTAAGAAAGGAGCTAAATTGTTACATAAACCTATTGTTTGGCATGTTAACAATGCAACTAATAAAGCCACGTATAAACCAAATACCTGGTGTATACGTTGTCTTTGGAGCACAAAACCAGTTGAAACATCAAATTCGTTTGATGTACTGAAGTCAGAGGACGCGCAGGGAATGGATAATCTTGCCTGCGAAGATCTAAAACCAGTCTCTGAAGAAGTAGTGGAAAATCCTACCATACAGAAAGACGTTCTTGAGTGTAATGTGAAAACTACCGAAGTTGTAGGAGACATTATACTTAAACCAGCAAATAATAGTTTAAAAATTACAGAAGAGGTTGGCCACACAGATCTAATGGCTGCTTATGTAGACAATTCTAGTCTTACTATTAAGAAACCTAATGAATTATCTAGAGTATTAGGTTTGAAAACCCTTGCTACTCATGGTTTAGCTGCTGTTAATAGTGTCCCTTGGGATACTATAGCTAATTATGCTAAGCCTTTTCTTAACAAAGTTGTTAGTACAACTACTAACATAGTTACACGGTGTTTAAACCGTGTTTGTACTAATTATATGCCTTATTTCTTTACTTTATTGCTACAATTGTGTACTTTTACTAGAAGTACAAATTCTAGAATTAAAGCATCTATGCCGACTACTATAGCAAAGAATACTGTTAAGAGTGTCGGTAAATTTTGTCTAGAGGCTTCATTTAATTATTTGAAGTCACCTAATTTTTCTAAACTGATAAATATTATAATTTGGTTTTTACTATTAAGTGTTTGCCTAGGTTCTTTAATCTACTCAACCGCTGCTTTAGGTGTTTTAATGTCTAATTTAGGCATGCCTTCTTACTGTACTGGTTACAGAGAAGGCTATTTGAACTCTACTAATGTCACTATTGCAACCTACTGTACTGGTTCTATACCTTGTAGTGTTTGTCTTAGTGGTTTAGATTCTTTAGACACCTATCCTTCTTTAGAAACTATACAAATTACCATTTCATCTTTTAAATGGGATTTAACTGCTTTTGGCTTAGTTGCAGAGTGGTTTTTGGCATATATTCTTTTCACTAGGTTTTTCTATGTACTTGGATTGGCTGCAATCATGCAATTGTTTTTCAGCTATTTTGCAGTACATTTTATTAGTAATTCTTGGCTTATGTGGTTAATAATTAATCTTGTACAAATGGCCCCGATTTCAGCTATGGTTAGAATGTACATCTTCTTTGCATCATTTTATTATGTATGGAAAAGTTATGTGCATGTTGTAGACGGTTGTAATTCATCAACTTGTATGATGTGTTACAAACGTAATAGAGCAACAAGAGTCGAATGTACAACTATTGTTAATGGTGTTAGAAGGTCCTTTTATGTCTATGCTAATGGAGGTAAAGGCTTTTGCAAACTACACAATTGGAATTGTGTTAATTGTGATACATTCTGTGCTGGTAGTACATTTATTAGTGATGAAGTTGCGAGAGACTTGTCACTACAGTTTAAAAGACCAATAAATCCTACTGACCAGTCTTCTTACATCGTTGATAGTGTTACAGTGAAGAATGGTTCCATCCATCTTTACTTTGATAAAGCTGGTCAAAAGACTTATGAAAGACATTCTCTCTCTCATTTTGTTAACTTAGACAACCTGAGAGCTAATAACACTAAAGGTTCATTGCCTATTAATGTTATAGTTTTTGATGGTAAATCAAAATGTGAAGAATCATCTGCAAAATCAGCGTCTGTTTACTACAGTCAGCTTATGTGTCAACCTATACTGTTACTAGATCAGGCATTAGTGTCTGATGTTGGTGATAGTGCGGAAGTTGCAGTTAAAATGTTTGATGCTTACGTTAATACGTTTTCATCAACTTTTAACGTACCAATGGAAAAACTCAAAACACTAGTTGCAACTGCAGAAGCTGAACTTGCAAAGAATGTGTCCTTAGACAATGTCTTATCTACTTTTATTTCAGCAGCTCGGCAAGGGTTTGTTGATTCAGATGTAGAAACTAAAGATGTTGTTGAATGTCTTAAATTGTCACATCAATCTGACATAGAAGTTACTGGCGATAGTTGTAATAACTATATGCTCACCTATAACAAAGTTGAAAACATGACACCCCGTGACCTTGGTGCTTGTATTGACTGTAGTGCGCGTCATATTAATGCGCAGGTAGCAAAAAGTCACAACATTGCTTTGATATGGAACGTTAAAGATTTCATGTCATTGTCTGAACAACTACGAAAACAAATACGTAGTGCTGCTAAAAAGAATAACTTACCTTTTAAGTTGACATGTGCAACTACTAGACAAGTTGTTAATGTTGTAACAACAAAGATAGCACTTAAGGGTGGTAAAATTGTTAATAATTGGTTGAAGCAGTTAATTAAAGTTACACTTGTGTTCCTTTTTGTTGCTGCTATTTTCTATTTAATAACACCTGTTCATGTCATGTCTAAACATACTGACTTTTCAAGTGAAATCATAGGATACAAGGCTATTGATGGTGGTGTCACTCGTGACATAGCATCTACAGATACTTGTTTTGCTAACAAACATGCTGATTTTGACACATGGTTTAGCCAGCGTGGTGGTAGTTATACTAATGACAAAGCTTGCCCATTGATTGCTGCAGTCATAACAAGAGAAGTGGGTTTTGTCGTGCCTGGTTTGCCTGGCACGATATTACGCACAACTAATGGTGACTTTTTGCATTTCTTACCTAGAGTTTTTAGTGCAGTTGGTAACATCTGTTACACACCATCAAAACTTATAGAGTACACTGACTTTGCAACATCAGCTTGTGTTTTGGCTGCTGAATGTACAATTTTTAAAGATGCTTCTGGTAAGCCAGTACCATATTGTTATGATACCAATGTACTAGAAGGTTCTGTTGCTTATGAAAGTTTACGCCCTGACACACGTTATGTGCTCATGGATGGCTCTATTATTCAATTTCCTAACACCTACCTTGAAGGTTCTGTTAGAGTGGTAACAACTTTTGATTCTGAGTACTGTAGGCACGGCACTTGTGAAAGATCAGAAGCTGGTGTTTGTGTATCTACTAGTGGTAGATGGGTACTTAACAATGATTATTACAGATCTTTACCAGGAGTTTTCTGTGGTGTAGATGCTGTAAATTTACTTACTAATATGTTTACACCACTAATTCAACCTATTGGTGCTTTGGACATATCAGCATCTATAGTAGCTGGTGGTATTGTAGCTATCGTAGTAACATGCCTTGCCTACTATTTTATGAGGTTTAGAAGAGCTTTTGGTGAATACAGTCATGTAGTTGCCTTTAATACTTTACTATTCCTTATGTCATTCACTGTACTCTGTTTAACACCAGTTTACTCATTCTTACCTGGTGTTTATTCTGTTATTTACTTGTACTTGACATTTTATCTTACTAATGATGTTTCTTTTTTAGCACATATTCAGTGGATGGTTATGTTCACACCTTTAGTACCTTTCTGGATAACAATTGCTTATATCATTTGTATTTCCACAAAGCATTTCTATTGGTTCTTTAGTAATTACCTAAAGAGACGTGTAGTCTTTAATGGTGTTTCCTTTAGTACTTTTGAAGAAGCTGCGCTGTGCACCTTTTTGTTAAATAAAGAAATGTATCTAAAGTTGCGTAGTGATGTGCTATTACCTCTTACGCAATATAATAGATACTTAGCTCTTTATAATAAGTACAAGTATTTTAGTGGAGCAATGGATACAACTAGCTACAGAGAAGCTGCTTGTTGTCATCTCGCAAAGGCTCTCAATGACTTCAGTAACTCAGGTTCTGATGTTCTTTACCAACCACCACAAACCTCTATCACCTCAGCTGTTTTGCAGAGTGGTTTTAGAAAAATGGCATTCCCATCTGGTAAAGTTGAGGGTTGTATGGTACAAGTAACTTGTGGTACAACTACACTTAACGGTCTTTGGCTTGATGACGTAGTTTACTGTCCAAGACATGTGATCTGCACCTCTGAAGACATGCTTAACCCTAATTATGAAGATTTACTCATTCGTAAGTCTAATCATAATTTCTTGGTACAGGCTGGTAATGTTCAACTCAGGGTTATTGGACATTCTATGCAAAATTGTGTACTTAAGCTTAAGGTTGATACAGCCAATCCTAAGACACCTAAGTATAAGTTTGTTCGCATTCAACCAGGACAGACTTTTTCAGTGTTAGCTTGTTACAATGGTTCACCATCTGGTGTTTACCAATGTGCTATGAGGCCCAATTTCACTATTAAGGGTTCATTCCTTAATGGTTCATGTGGTAGTGTTGGTTTTAACATAGATTATGACTGTGTCTCTTTTTGTTACATGCACCATATGGAATTACCAACTGGAGTTCATGCTGGCACAGACTTAGAAGGTAACTTTTATGGACCTTTTGTTGACAGGCAAACAGCACAAGCAGCTGGTACGGACACAACTATTACAGTTAATGTTTTAGCTTGGTTGTACGCTGCTGTTATAAATGGAGACAGGTGGTTTCTCAATCGATTTACCACAACTCTTAATGACTTTAACCTTGTGGCTATGAAGTACAATTATGAACCTCTAACACAAGACCATGTTGACATACTAGGACCTCTTTCTGCTCAAACTGGAATTGCCGTTTTAGATATGTGTGCTTCATTAAAAGAATTACTGCAAAATGGTATGAATGGACGTACCATATTGGGTAGTGCTTTATTAGAAGATGAATTTACACCTTTTGATGTTGTTAGACAATGCTCAGGTGTTACTTTCCAAAGTGCAGTGAAAAGAACAATCAAGGGTACACACCACTGGTTGTTACTCACAATTTTGACTTCACTTTTAGTTTTAGTCCAGAGTACTCAATGGTCTTTGTTCTTTTTTTTGTATGAAAATGCCTTTTTACCTTTTGCTATGGGTATTATTGCTATGTCTGCTTTTGCAATGATGTTTGTCAAACATAAGCATGCATTTCTCTGTTTGTTTTTGTTACCTTCTCTTGCCACTGTAGCTTATTTTAATATGGTCTATATGCCTGCTAGTTGGGTGATGCGTATTATGACATGGTTGGATATGGTTGATACTAGTTTGTCTGGTTTTAAGCTAAAAGACTGTGTTATGTATGCATCAGCTGTAGTGTTACTAATCCTTATGACAGCAAGAACTGTGTATGATGATGGTGCTAGGAGAGTGTGGACACTTATGAATGTCTTGACACTCGTTTATAAAGTTTATTATGGTAATGCTTTAGATCAAGCCATTTCCATGTGGGCTCTTATAATCTCTGTTACTTCTAACTACTCAGGTGTAGTTACAACTGTCATGTTTTTGGCCAGAGGTATTGTTTTTATGTGTGTTGAGTATTGCCCTATTTTCTTCATAACTGGTAATACACTTCAGTGTATAATGCTAGTTTATTGTTTCTTAGGCTATTTTTGTACTTGTTACTTTGGCCTCTTTTGTTTACTCAACCGCTACTTTAGACTGACTCTTGGTGTTTATGATTACTTAGTTTCTACACAGGAGTTTAGATATATGAATTCACAGGGACTACTCCCACCCAAGAATAGCATAGATGCCTTCAAACTCAACATTAAATTGTTGGGTGTTGGTGGCAAACCTTGTATCAAAGTAGCCACTGTACAGTCTAAAATGTCAGATGTAAAGTGCACATCAGTAGTCTTACTCTCAGTTTTGCAACAACTCAGAGTAGAATCATCATCTAAATTGTGGGCTCAATGTGTCCAGTTACACAATGACATTCTCTTAGCTAAAGATACTACTGAAGCCTTTGAAAAAATGGTTTCACTACTTTCTGTTTTGCTTTCCATGCAGGGTGCTGTAGACATAAACAAGCTTTGTGAAGAAATGCTGGACAACAGGGCAACCTTACAAGCTATAGCCTCAGAGTTTAGTTCCCTTCCATCATATGCAGCTTTTGCTACTGCTCAAGAAGCTTATGAGCAGGCTGTTGCTAATGGTGATTCTGAAGTTGTTCTTAAAAAGTTGAAGAAGTCTTTGAATGTGGCTAAATCTGAATTTGACCGTGATGCAGCCATGCAACGTAAGTTGGAAAAGATGGCTGATCAAGCTATGACCCAAATGTATAAACAGGCTAGATCTGAGGACAAGAGGGCAAAAGTTACTAGTGCTATGCAGACAATGCTTTTCACTATGCTTAGAAAGTTGGATAATGATGCACTCAACAACATTATCAACAATGCAAGAGATGGTTGTGTTCCCTTGAACATAATACCTCTTACAACAGCAGCCAAACTAATGGTTGTCATACCAGACTATAACACATATAAAAATACGTGTGATGGTACAACATTTACTTATGCATCAGCATTGTGGGAAATCCAACAGGTTGTAGATGCAGATAGTAAAATTGTTCAACTTAGTGAAATTAGTATGGACAATTCACCTAATTTAGCATGGCCTCTTATTGTAACAGCTTTAAGGGCCAATTCTGCTGTCAAATTACAGAATAATGAGCTTAGTCCTGTTGCACTACGACAGATGTCTTGTGCTGCCGGTACTACACAAACTGCTTGCACTGATGACAATGCGTTAGCTTACTACAACACAACAAAGGGAGGTAGGTTTGTACTTGCACTGTTATCCGATTTACAGGATTTGAAATGGGCTAGATTCCCTAAGAGTGATGGAACTGGTACTATCTATACAGAACTGGAACCACCTTGTAGGTTTGTTACAGACACACCTAAAGGTCCTAAAGTGAAGTATTTATACTTTATTAAAGGATTAAACAACCTAAATAGAGGTATGGTACTTGGTAGTTTAGCTGCCACAGTACGTCTACAAGCTGGTAATGCAACAGAAGTGCCTGCCAATTCAACTGTATTATCTTTCTGTGCTTTTGCTGTAGATGCTGCTAAAGCTTACAAAGATTATCTAGCTAGTGGGGGACAACCAATCACTAATTGTGTTAAGATGTTGTGTACACACACTGGTACTGGTCAGGCAATAACAGTTACACCGGAAGCCAATATGGATCAAGAATCCTTTGGTGGTGCATCGTGTTGTCTGTACTGCCGTTGCCACATAGATCATCCAAATCCTAAAGGATTTTGTGACTTAAAAGGTAAGTATGTACAAATACCTACAACTTGTGCTAATGACCCTGTGGGTTTTACACTTAAAAACACAGTCTGTACCGTCTGCGGTATGTGGAAAGGTTATGGCTGTAGTTGTGATCAACTCCGCGAACCCATGCTTCAGTCAGCTGATGCACAATCGTTTTTAAACCGGGTTTGCGGTGTAAGTGCAGCCCGTCTTACACCGTGCGGCACAGGCACTAGTACTGATGTCGTATACAGGGCTTTTGACATCTACAATGATAAAGTAGCTGGTTTTGCTAAATTCCTAAAAACTAATTGTTGTCGCTTCCAAGAAAAGGACGAAGATGACAATTTAATTGATTCTTACTTTGTAGTTAAGAGACACACTTTCTCTAACTACCAACATGAAGAAACAATTTATAATTTACTTAAGGATTGTCCAGCTGTTGCTAAACATGACTTCTTTAAGTTTAGAATAGACGGTGACATGGTACCACATATATCACGTCAACGTCTTACTAAATACACAATGGCAGACCTCGTCTATGCTTTAAGGCATTTTGATGAAGGTAATTGTGACACATTAAAAGAAATACTTGTCACATACAATTGTTGTGATGATGATTATTTCAATAAAAAGGACTGGTATGATTTTGTAGAAAACCCAGATATATTACGCGTATACGCCAACTTAGGTGAACGTGTACGCCAAGCTTTGTTAAAAACAGTACAATTCTGTGATGCCATGCGAAATGCTGGTATTGTTGGTGTACTGACATTAGATAATCAAGATCTCAATGGTAACTGGTATGATTTCGGTGATTTCATACAAACCACGCCAGGTAGTGGAGTTCCTGTTGTAGATTCTTATTATTCATTGTTAATGCCTATATTAACCTTGACCAGGGCTTTAACTGCAGAGTCACATGTTGACACTGACTTAACAAAGCCTTACATTAAGTGGGATTTGTTAAAATATGACTTCACGGAAGAGAGGTTAAAACTCTTTGACCGTTATTTTAAATATTGGGATCAGACATACCACCCAAATTGTGTTAACTGTTTGGATGACAGATGCATTCTGCATTGTGCAAACTTTAATGTTTTATTCTCTACAGTGTTCCCACCTACAAGTTTTGGACCACTAGTGAGAAAAATATTTGTTGATGGTGTTCCATTTGTAGTTTCAACTGGATACCACTTCAGAGAGCTAGGTGTTGTACATAATCAGGATGTAAACTTACATAGCTCTAGACTTAGTTTTAAGGAATTACTTGTGTATGCTGCTGACCCTGCTATGCACGCTGCTTCTGGTAATCTATTACTAGATAAACGCACTACGTGCTTTTCAGTAGCTGCACTTACTAACAATGTTGCTTTTCAAACTGTCAAACCCGGTAATTTTAACAAAGACTTCTATGACTTTGCTGTGTCTAAGGGTTTCTTTAAGGAAGGAAGTTCTGTTGAATTAAAACACTTCTTCTTTGCTCAGGATGGTAATGCTGCTATCAGCGATTATGACTACTATCGTTATAATCTACCAACAATGTGTGATATCAGACAACTACTATTTGTAGTTGAAGTTGTTGATAAGTACTTTGATTGTTACGATGGTGGCTGTATTAATGCTAACCAAGTCATCGTCAACAACCTAGACAAATCAGCTGGTTTTCCATTTAATAAATGGGGTAAGGCTAGACTTTATTATGATTCAATGAGTTATGAGGATCAAGATGCACTTTTCGCATATACAAAACGTAATGTCATCCCTACTATAACTCAAATGAATCTTAAGTATGCCATTAGTGCAAAGAATAGAGCTCGCACCGTAGCTGGTGTCTCTATCTGTAGTACTATGACCAATAGACAGTTTCATCAAAAATTATTGAAATCAATAGCCGCCACTAGAGGAGCTACTGTAGTAATTGGAACAAGCAAATTCTATGGTGGTTGGCACAACATGTTAAAAACTGTTTATAGTGATGTAGAAAACCCTCACCTTATGGGTTGGGATTATCCTAAATGTGATAGAGCCATGCCTAACATGCTTAGAATTATGGCCTCACTTGTTCTTGCTCGCAAACATACAACGTGTTGTAGCTTGTCACACCGTTTCTATAGATTAGCTAATGAGTGTGCTCAAGTATTGAGTGAAATGGTCATGTGTGGCGGTTCACTATATGTTAAACCAGGTGGAACCTCATCAGGAGATGCCACAACTGCTTATGCTAATAGTGTTTTTAACATTTGTCAAGCTGTCACGGCCAATGTTAATGCACTTTTATCTACTGATGGTAACAAAATTGCCGATAAGTATGTCCGCAATTTACAACACAGACTTTATGAGTGTCTCTATAGAAATAGAGATGTTGACACAGACTTTGTGAATGAGTTTTACGCATATTTGCGTAAACATTTCTCAATGATGATACTCTCTGACGATGCTGTTGTGTGTTTCAATAGCACTTATGCATCTCAAGGTCTAGTGGCTAGCATAAAGAACTTTAAGTCAGTTCTTTATTATCAAAACAATGTTTTTATGTCTGAAGCAAAATGTTGGACTGAGACTGACCTTACTAAAGGACCTCATGAATTTTGCTCTCAACATACAATGCTAGTTAAACAGGGTGATGATTATGTGTACCTTCCTTACCCAGATCCATCAAGAATCCTAGGGGCCGGCTGTTTTGTAGATGATATCGTAAAAACAGATGGTACACTTATGATTGAACGGTTCGTGTCTTTAGCTATAGATGCTTACCCACTTACTAAACATCCTAATCAGGAGTATGCTGATGTCTTTCATTTGTACTTACAATACATAAGAAAGCTACATGATGAGTTAACAGGACACATGTTAGACATGTATTCTGTTATGCTTACTAATGATAACACTTCAAGGTATTGGGAACCTGAGTTTTATGAGGCTATGTACACACCGCATACAGTCTTACAGGCTGTTGGGGCTTGTGTTCTTTGCAATTCACAGACTTCATTAAGATGTGGTGCTTGCATACGTAGACCATTCTTATGTTGTAAATGCTGTTACGACCATGTCATATCAACATCACATAAATTAGTCTTGTCTGTTAATCCGTATGTTTGCAATGCTCCAGGTTGTGATGTCACAGATGTGACTCAACTTTACTTAGGAGGTATGAGCTATTATTGTAAATCACATAAACCACCCATTAGTTTTCCATTGTGTGCTAATGGACAAGTTTTTGGTTTATATAAAAATACATGTGTTGGTAGCGATAATGTTACTGACTTTAATGCAATTGCAACATGTGACTGGACAAATGCTGGTGATTACATTTTAGCTAACACCTGTACTGAAAGACTCAAGCTTTTTGCAGCAGAAACGCTCAAAGCTACTGAGGAGACATTTAAACTGTCTTATGGTATTGCTACTGTACGTGAAGTGCTGTCTGACAGAGAATTACATCTTTCATGGGAAGTTGGTAAACCTAGACCACCACTTAACCGAAATTATGTCTTTACTGGTTATCGTGTAACTAAAAACAGTAAAGTACAAATAGGAGAGTACACCTTTGAAAAAGGTGACTATGGTGATGCTGTTGTTTACCGAGGTACAACAACTTACAAATTAAATGTTGGTGATTATTTTGTGCTGACATCACATACAGTAATGCCATTAAGTGCACCTACACTAGTGCCACAAGAGCACTATGTTAGAATTACTGGCTTATACCCAACACTCAATATCTCAGATGAGTTTTCTAGCAATGTTGCAAATTATCAAAAGGTTGGTATGCAAAAGTATTCTACACTCCAGGGACCACCTGGTACTGGTAAGAGTCATTTTGCTATTGGCCTAGCTCTCTACTACCCTTCTGCTCGCATAGTGTATACAGCTTGCTCTCATGCCGCTGTTGATGCACTATGTGAGAAGGCATTAAAATATTTGCCTATAGATAAATGTAGTAGAATTATACCTGCACGTGCTCGTGTAGAGTGTTTTGATAAATTCAAAGTGAATTCAACATTAGAACAGTATGTCTTTTGTACTGTAAATGCATTGCCTGAGACGACAGCAGATATAGTTGTCTTTGATGAAATTTCAATGGCCACAAATTATGATTTGAGTGTTGTCAATGCCAGATTACGTGCTAAGCACTATGTGTACATTGGCGACCCTGCTCAATTACCTGCACCACGCACATTGCTAACTAAGGGCACACTAGAACCAGAATATTTCAATTCAGTGTGTAGACTTATGAAAACTATAGGTCCAGACATGTTCCTCGGAACTTGTCGGCGTTGTCCTGCTGAAATTGTTGACACTGTGAGTGCTTTGGTTTATGATAATAAGCTTAAAGCACATAAAGACAAATCAGCTCAATGCTTTAAAATGTTTTATAAGGGTGTTATCACGCATGATGTTTCATCTGCAATTAACAGGCCACAAATAGGCGTGGTAAGAGAATTCCTTACACGTAACCCTGCTTGGAGAAAAGCTGTCTTTATTTCACCTTATAATTCACAGAATGCTGTAGCCTCAAAGATTTTGGGACTACCAACTCAAACTGTTGATTCATCACAGGGCTCAGAATATGACTATGTCATATTCACTCAAACCACTGAAACAGCTCACTCTTGTAATGTAAACAGATTTAATGTTGCTATTACCAGAGCAAAAGTAGGCATACTTTGCATAATGTCTGATAGAGACCTTTATGACAAGTTGCAATTTACAAGTCTTGAAATTCCACGTAGGAATGTGGCAACTTTACAAGCTGAAAATGTAACAGGACTCTTTAAAGATTGTAGTAAGGTAATCACTGGGTTACATCCTACACAGGCACCTACACACCTCAGTGTTGACACTAAATTCAAAACTGAAGGTTTATGTGTTGACATACCTGGCATACCTAAGGACATGACCTATAGAAGACTCATCTCTATGATGGGTTTTAAAATGAATTATCAAGTTAATGGTTACCCTAACATGTTTATCACCCGCGAAGAAGCTATAAGACATGTACGTGCATGGATTGGCTTCGATGTCGAGGGGTGTCATGCTACTAGAGAAGCTGTTGGTACCAATTTACCTTTACAGCTAGGTTTTTCTACAGGTGTTAACCTAGTTGCTGTACCTACAGGTTATGTTGATACACCTAATAATACAGATTTTTCCAGAGTTAGTGCTAAACCACCGCCTGGAGATCAATTTAAACACCTCATACCACTTATGTACAAAGGACTTCCTTGGAATGTAGTGCGTATAAAGATTGTACAAATGTTAAGTGACACACTTAAAAATCTCTCTGACAGAGTCGTATTTGTCTTATGGGCACATGGCTTTGAGTTGACATCTATGAAGTATTTTGTGAAAATAGGACCTGAGCGCACCTGTTGTCTATGTGATAGACGTGCCACATGCTTTTCCACTGCTTCAGACACTTATGCCTGTTGGCATCATTCTATTGGATTTGATTACGTCTATAATCCGTTTATGATTGATGTTCAACAATGGGGTTTTACAGGTAACCTACAAAGCAACCATGATCTGTATTGTCAAGTCCATGGTAATGCACATGTAGCTAGTTGTGATGCAATCATGACTAGGTGTCTAGCTGTCCACGAGTGCTTTGTTAAGCGTGTTGACTGGACTATTGAATATCCTATAATTGGTGATGAACTGAAGATTAATGCGGCTTGTAGAAAGGTTCAACACATGGTTGTTAAAGCTGCATTATTAGCAGACAAATTCCCAGTTCTTCACGACATTGGTAACCCTAAAGCTATTAAGTGTGTACCTCAAGCTGATGTAGAATGGAAGTTCTATGATGCACAGCCTTGTAGTGACAAAGCTTATAAAATAGAAGAATTATTCTATTCTTATGCCACACATTCTGACAAATTCACAGATGGTGTATGCCTATTTTGGAATTGCAATGTCGATAGATATCCTGCTAATTCCATTGTTTGTAGATTTGACACTAGAGTGCTATCTAACCTTAACTTGCCTGGTTGTGATGGTGGCAGTTTGTATGTAAATAAACATGCATTCCACACACCAGCTTTTGATAAAAGTGCTTTTGTTAATTTAAAACAATTACCATTTTTCTATTACTCTGACAGTCCATGTGAGTCTCATGGAAAACAAGTAGTGTCAGATATAGATTATGTACCACTAAAGTCTGCTACGTGTATAACACGTTGCAATTTAGGTGGTGCTGTCTGTAGACATCATGCTAATGAGTACAGATTGTATCTCGATGCTTATAACATGATGATCTCAGCTGGCTTTAGCTTGTGGGTTTACAAACAATTTGATACTTATAACCTCTGGAACACTTTTACAAGACTTCAGAGTTTAGAAAATGTGGCTTTTAATGTTGTAAATAAGGGACACTTTGATGGACAACAGGGTGAAGTACCAGTTTCTATCATTAATAACACTGTTTACACAAAAGTTGATGGTGTTGATGTAGAATTGTTTGAAAATAAAACAACATTACCTGTTAATGTAGCATTTGAGCTTTGGGCTAAGCGCAACATTAAACCAGTACCAGAGGTGAAAATACTCAATAATTTGGGTGTGGACATTGCTGCTAATACTGTGATCTGGGACTACAAAAGAGATGCTCCAGCACATATATCTACTATTGGTGTTTGTTCTATGACTGACATAGCCAAGAAACCAACTGAAACGATTTGTGCACCACTCACTGTCTTTTTTGATGGTAGAGTTGATGGTCAAGTAGACTTATTTAGAAATGCCCGTAATGGTGTTCTTATTACAGAAGGTAGTGTTAAAGGTTTACAACCATCTGTAGGTCCCAAACAAGCTAGTCTTAATGGAGTCACATTAATTGGAGAAGCCGTAAAAACACAGTTCAATTATTATAAGAAAGTTGATGGTGTTGTCCAACAATTACCTGAAACTTACTTTACTCAGAGTAGAAATTTACAAGAATTTAAACCCAGGAGTCAAATGGAAATTGATTTCTTAGAATTAGCTATGGATGAATTCATTGAACGGTATAAATTAGAAGGCTATGCCTTCGAACATATCGTTTATGGAGATTTTAGTCATAGTCAGTTAGGTGGTTTACATCTACTGATTGGACTAGCTAAACGTTTTAAGGAATCACCTTTTGAATTAGAAGATTTTATTCCTATGGACAGTACAGTTAAAAACTATTTCATAACAGATGCGCAAACAGGTTCATCTAAGTGTGTGTGTTCTGTTATTGATTTATTACTTGATGATTTTGTTGAAATAATAAAATCCCAAGATTTATCTGTAGTTTCTAAGGTTGTCAAAGTGACTATTGACTATACAGAAATTTCATTTATGCTTTGGTGTAAAGATGGCCATGTAGAAACATTTTACCCAAAATTACAATCTAGTCAAGCGTGGCAACCGGGTGTTGCTATGCCTAATCTTTACAAAATGCAAAGAATGCTATTAGAAAAGTGTGACCTTCAAAATTATGGTGATAGTGCAACATTACCTAAAGGCATAATGATGAATGTCGCAAAATATACTCAACTGTGTCAATATTTAAACACATTAACATTAGCTGTACCCTATAATATGAGAGTTATACATTTTGGTGCTGGTTCTGATAAAGGAGTTGCACCAGGTACAGCTGTTTTAAGACAGTGGTTGCCTACGGGTACGCTGCTTGTCGATTCAGATCTTAATGACTTTGTCTCTGATGCAGATTCAACTTTGATTGGTGATTGTGCAACTGTACATACAGCTAATAAATGGGATCTCATTATTAGTGATATGTACGACCCTAAGACTAAAAATGTTACAAAAGAAAATGACTCTAAAGAGGGTTTTTTCACTTACATTTGTGGGTTTATACAACAAAAGCTAGCTCTTGGAGGTTCCGTGGCTATAAAGATAACAGAACATTCTTGGAATGCTGATCTTTATAAGCTCATGGGACACTTCGCATGGTGGACAGCCTTTGTTACTAATGTGAATGCGTCATCATCTGAAGCATTTTTAATTGGATGTAATTATCTTGGCAAACCACGCGAACAAATAGATGGTTATGTCATGCATGCAAATTACATATTTTGGAGGAATACAAATCCAATTCAGTTGTCTTCCTATTCTTTATTTGACATGAGTAAATTTCCCCTTAAATTAAGGGGTACTGCTGTTATGTCTTTAAAAGAAGGTCAAATCAATGATATGATTTTATCTCTTCTTAGTAAAGGTAGACTTATAATTAGAGAAAACAACAGAGTTGTTATTTCTAGTGATGTTCTTGTTAACAACTAAACGAACAATGTTTGTTTTTCTTGTTTTATTGCCACTAGTCTCTAGTCAGTGTGTTAATCTTACAACCAGAACTCAATTACCCCCTGCATACACTAATTCTTTCACACGTGGTGTTTATTACCCTGACAAAGTTTTCAGATCCTCAGTTTTACATTCAACTCAGGACTTGTTCTTACCTTTCTTTTCCAATGTTACTTGGTTCCATGCTATACATGTCTCTGGGACCAATGGTACTAAGAGGTTTGATAACCCTGTCCTACCATTTAATGATGGTGTTTATTTTGCTTCCACTGAGAAGTCTAACATAATAAGAGGCTGGATTTTTGGTACTACTTTAGATTCGAAGACCCAGTCCCTACTTATTGTTAATAACGCTACTAATGTTGTTATTAAAGTCTGTGAATTTCAATTTTGTAATGATCCATTTTTGGGTGTTTATTACCACAAAAACAACAAAAGTTGGATGGAAAGTGAGTTCAGAGTTTATTCTAGTGCGAATAATTGCACTTTTGAATATGTCTCTCAGCCTTTTCTTATGGACCTTGAAGGAAAACAGGGTAATTTCAAAAATCTTAGGGAATTTGTGTTTAAGAATATTGATGGTTATTTTAAAATATATTCTAAGCACACGCCTATTAATTTAGTGCGTGATCTCCCTCAGGGTTTTTCGGCTTTAGAACCATTGGTAGATTTGCCAATAGGTATTAACATCACTAGGTTTCAAACTTTACTTGCTTTACATAGAAGTTATTTGACTCCTGGTGATTCTTCTTCAGGTTGGACAGCTGGTGCTGCAGCTTATTATGTGGGTTATCTTCAACCTAGGACTTTTCTATTAAAATATAATGAAAATGGAACCATTACAGATGCTGTAGACTGTGCACTTGACCCTCTCTCAGAAACAAAGTGTACGTTGAAATCCTTCACTGTAGAAAAAGGAATCTATCAAACTTCTAACTTTAGAGTCCAACCAACAGAATCTATTGTTAGATTTCCTAATATTACAAACTTGTGCCCTTTTGGTGAAGTTTTTAACGCCACCAGATTTGCATCTGTTTATGCTTGGAACAGGAAGAGAATCAGCAACTGTGTTGCTGATTATTCTGTCCTATATAATTCCGCATCATTTTCCACTTTTAAGTGTTATGGAGTGTCTCCTACTAAATTAAATGATCTCTGCTTTACTAATGTCTATGCAGATTCATTTGTAATTAGAGGTGATGAAGTCAGACAAATCGCTCCAGGGCAAACTGGAAAGATTGCTGATTATAATTATAAATTACCAGATGATTTTACAGGCTGCGTTATAGCTTGGAATTCTAACAATCTTGATTCTAAGGTTGGTGGTAATTATAATTACCTGTATAGATTGTTTAGGAAGTCTAATCTCAAACCTTTTGAGAGAGATATTTCAACTGAAATCTATCAGGCCGGTAGCACACCTTGTAATGGTGTTGAAGGTTTTAATTGTTACTTTCCTTTACAATCATATGGTTTCCAACCCACTAATGGTGTTGGTTACCAACCATACAGAGTAGTAGTACTTTCTTTTGAACTTCTACATGCACCAGCAACTGTTTGTGGACCTAAAAAGTCTACTAATTTGGTTAAAAACAAATGTGTCAATTTCAACTTCAATGGTTTAACAGGCACAGGTGTTCTTACTGAGTCTAACAAAAAGTTTCTGCCTTTCCAACAATTTGGCAGAGACATTGCTGACACTACTGATGCTGTCCGTGATCCACAGACACTTGAGATTCTTGACATTACACCATGTTCTTTTGGTGGTGTCAGTGTTATAACACCAGGAACAAATACTTCTAACCAGGTTGCTGTTCTTTATCAGGATGTTAACTGCACAGAAGTCCCTGTTGCTATTCATGCAGATCAACTTACTCCTACTTGGCGTGTTTATTCTACAGGTTCTAATGTTTTTCAAACACGTGCAGGCTGTTTAATAGGGGCTGAACATGTCAACAACTCATATGAGTGTGACATACCCATTGGTGCAGGTATATGCGCTAGTTATCAGACTCAGACTAATTCTCCTCGGCGGGCACGTAGTGTAGCTAGTCAATCCATCATTGCCTACACTATGTCACTTGGTGCAGAAAATTCAGTTGCTTACTCTAATAACTCTATTGCCATACCCACAAATTTTACTATTAGTGTTACCACAGAAATTCTACCAGTGTCTATGACCAAGACATCAGTAGATTGTACAATGTACATTTGTGGTGATTCAACTGAATGCAGCAATCTTTTGTTGCAATATGGCAGTTTTTGTACACAATTAAACCGTGCTTTAACTGGAATAGCTGTTGAACAAGACAAAAACACCCAAGAAGTTTTTGCACAAGTCAAACAAATTTACAAAACACCACCAATTAAAGATTTTGGTGGTTTTAATTTTTCACAAATATTACCAGATCCATCAAAACCAAGCAAGAGGTCATTTATTGAAGATCTACTTTTCAACAAAGTGACACTTGCAGATGCTGGCTTCATCAAACAATATGGTGATTGCCTTGGTGATATTGCTGCTAGAGACCTCATTTGTGCACAAAAGTTTAACGGCCTTACTGTTTTGCCACCTTTGCTCACAGATGAAATGATTGCTCAATACACTTCTGCACTGTTAGCGGGTACAATCACTTCTGGTTGGACCTTTGGTGCAGGTGCTGCATTACAAATACCATTTGCTATGCAAATGGCTTATAGGTTTAATGGTATTGGAGTTACACAGAATGTTCTCTATGAGAACCAAAAATTGATTGCCAACCAATTTAATAGTGCTATTGGCAAAATTCAAGACTCACTTTCTTCCACAGCAAGTGCACTTGGAAAACTTCAAGATGTGGTCAACCAAAATGCACAAGCTTTAAACACGCTTGTTAAACAACTTAGCTCCAATTTTGGTGCAATTTCAAGTGTTTTAAATGATATCCTTTCACGTCTTGACAAAGTTGAGGCTGAAGTGCAAATTGATAGGTTGATCACAGGCAGACTTCAAAGTTTGCAGACATATGTGACTCAACAATTAATTAGAGCTGCAGAAATCAGAGCTTCTGCTAATCTTGCTGCTACTAAAATGTCAGAGTGTGTACTTGGACAATCAAAAAGAGTTGATTTTTGTGGAAAGGGCTATCATCTTATGTCCTTCCCTCAGTCAGCACCTCATGGTGTAGTCTTCTTGCATGTGACTTATGTCCCTGCACAAGAAAAGAACTTCACAACTGCTCCTGCCATTTGTCATGATGGAAAAGCACACTTTCCTCGTGAAGGTGTCTTTGTTTCAAATGGCACACACTGGTTTGTAACACAAAGGAATTTTTATGAACCACAAATCATTACTACAGACAACACATTTGTGTCTGGTAACTGTGATGTTGTAATAGGAATTGTCAACAACACAGTTTATGATCCTTTGCAACCTGAATTAGACTCATTCAAGGAGGAGTTAGATAAATATTTTAAGAATCATACATCACCAGATGTTGATTTAGGTGACATCTCTGGCATTAATGCTTCAGTTGTAAACATTCAAAAAGAAATTGACCGCCTCAATGAGGTTGCCAAGAATTTAAATGAATCTCTCATCGATCTCCAAGAACTTGGAAAGTATGAGCAGTATATAAAATGGCCATGGTACATTTGGCTAGGTTTTATAGCTGGCTTGATTGCCATAGTAATGGTGACAATTATGCTTTGCTGTATGACCAGTTGCTGTAGTTGTCTCAAGGGCTGTTGTTCTTGTGGATCCTGCTGCAAATTTGATGAAGACGACTCTGAGCCAGTGCTCAAAGGAGTCAAATTACATTACACATAAACGAACTTATGGATTTGTTTATGAGAATCTTCACAATTGGAACTGTAACTTTGAAGCAAGGTGAAATCAAGGATGCTACTCCTTCAGATTTTGTTCGCGCTACTGCAACGATACCGATACAAGCCTCACTCCCTTTCGGATGGCTTATTGTTGGCGTTGCACTTCTTGCTGTTTTTCAGAGCGCTTCCAAAATCATAACCCTCAAAAAGAGATGGCAACTAGCACTCTCCAAGGGTGTTCACTTTGTTTGCAACTTGCTGTTGTTGTTTGTAACAGTTTACTCACACCTTTTGCTCGTTGCTGCTGGCCTTGAAGCCCCTTTTCTCTATCTTTATGCTTTAGTCTACTTCTTGCAGAGTATAAACTTTGTAAGAATAATAATGAGGCTTTGGCTTTGCTGGAAATGCCGTTCCAAAAACCCATTACTTTATGATGCCAACTATTTTCTTTGCTGGCATACTAATTGTTACGACTATTGTATACCTTACAATAGTGTAACTTCTTCAATTGTCATTACTTCAGGTGATGGCACAACAAGTCCTATTTCTGAACATGACTACCAGATTGGTGGTTATACTGAAAAATGGGAATCTGGAGTAAAAGACTGTGTTGTATTACACAGTTACTTCACTTCAGACTATTACCAGCTGTACTCAACTCAATTGAGTACAGACACTGGTGTTGAACATGTTACCTTCTTCATCTACAATAAAATTGTTGATGAGCCTGAAGAACATGTCCAAATTCACACAATCGACGGTTCATCCGGAGTTGTTAATCCAGTAATGGAACCAATTTATGATGAACCGACGACGACTACTAGCGTGCCTTTGTAAGCACAAGCTGATGAGTACGAACTTATGTACTCATTCGTTTCGGAAGAGACAGGTACGTTAATAGTTAATAGCGTACTTCTTTTTCTTGCTTTCGTGGTATTCTTGCTAGTTACACTAGCCATCCTTACTGCGCTTCGATTGTGTGCGTACTGCTGCAATATTGTTAACGTGAGTCTTGTAAAACCTTCTTTTTACGTTTACTCTCGTGTTAAAAATCTGAATTCTTCTAGAGTTCCTGATCTTCTGGTCTAAACGAACTAAATATTATATTAGTTTTTCTGTTTGGAACTTTAATTTTAGCCATGGCAGATTCCAACGGTACTATTACCGTTGAAGAGCTTAAAAAGCTCCTTGAACAATGGAACCTAGTAATAGGTTTCCTATTCCTTACATGGATTTGTCTTCTACAATTTGCCTATGCCAACAGGAATAGGTTTTTGTATATAATTAAGTTAATTTTCCTCTGGCTGTTATGGCCAGTAACTTTAGCTTGTTTTGTGCTTGCTGCTGTTTACAGAATAAATTGGATCACCGGTGGAATTGCTATCGCAATGGCTTGTCTTGTAGGCTTGATGTGGCTCAGCTACTTCATTGCTTCTTTCAGACTGTTTGCGCGTACGCGTTCCATGTGGTCATTCAATCCAGAAACTAACATTCTTCTCAACGTGCCACTCCATGGCACTATTCTGACCAGACCGCTTCTAGAAAGTGAACTCGTAATCGGAGCTGTGATCCTTCGTGGACATCTTCGTATTGCTGGACACCATCTAGGACGCTGTGACATCAAGGACCTGCCTAAAGAAATCACTGTTGCTACATCACGAACGCTTTCTTATTACAAATTGGGAGCTTCGCAGCGTGTAGCAGGTGACTCAGGTTTTGCTGCATACAGTCGCTACAGGATTGGCAACTATAAATTAAACACAGACCATTCCAGTAGCAGTGACAATATTGCTTTGCTTGTACAGTAAGTGACAACAGATGTTTCATCTCGTTGACTTTCAGGTTACTATAGCAGAGATATTACTAATTATTATGAGGACTTTTAAAGTTTCCATTTGGAATCTTGATTACATCATAAACCTCATAATTAAAAATTTATCTAAGTCACTAACTGAGAATAAATATTCTCAATTAGATGAAGAGCAACCAATGGAGATTGATTAAACGAACATGAAAATTATTCTTTTCTTGGCACTGATAACACTCGCTACTTGTGAGCTTTATCACTACCAAGAGTGTGTTAGAGGTACAACAGTACTTTTAAAAGAACCTTGCTCTTCTGGAACATACGAGGGCAATTCACCATTTCATCCTCTAGCTGATAACAAATTTGCACTGACTTGCTTTAGCACTCAATTTGCTTTTGCTTGTCCTGACGGCGTAAAACACGTCTATCAGTTACGTGCCAGATCAGTTTCACCTAAACTGTTCATCAGACAAGAGGAAGTTCAAGAACTTTACTCTCCAATTTTTCTTATTGTTGCGGCAATAGTGTTTATAACACTTTGCTTCACACTCAAAAGAAAGACAGAATGATTGAACTTTCATTAATTGACTTCTATTTGTGCTTTTTAGCCTTTCTGCTATTCCTTGTTTTAATTATGCTTATTATCTTTTGGTTCTCACTTGAACTGCAAGATCATAATGAAACTTGTCACGCCTAAACGAACATGAAATTTCTTGTTTTCTTAGGAATCATCACAACTGTAGCTGCATTTCACCAAGAATGTAGTTTACAGTCATGTACTCAACATCAACCATATGTAGTTGATGACCCGTGTCCTATTCACTTCTATTCTAAATGGTATATTAGAGTAGGAGCTAGAAAATCAGCACCTTTAATTGAATTGTGCGTGGATGAGGCTGGTTCTAAATCACCCATTCAGTACATCGATATCGGTAATTATACAGTTTCCTGTTTACCTTTTACAATTAATTGCCAGGAACCTAAATTGGGTAGTCTTGTAGTGCGTTGTTCGTTCTATGAAGACTTTTTAGAGTATCATGACGTTCGTGTTGTTTTAGATTTCATCTAAACGAACAAACTAAAATGTCTGATAATGGACCCCAAAATCAGCGAAATGCACCCCGCATTACGTTTGGTGGACCCTCAGATTCAACTGGCAGTAACCAGAATGGAGAACGCAGTGGGGCGCGATCAAAACAACGTCGGCCCCAAGGTTTACCCAATAATACTGCGTCTTGGTTCACCGCTCTCACTCAACATGGCAAGGAAGACCTTAAATTCCCTCGAGGACAAGGCGTTCCAATTAACACCAATAGCAGTCCAGATGACCAAATTGGCTACTACCGAAGAGCTACCAGACGAATTCGTGGTGGTGACGGTAAAATGAAAGATCTCAGTCCAAGATGGTATTTCTACTACCTAGGAACTGGGCCAGAAGCTGGACTTCCCTATGGTGCTAACAAAGACGGCATCATATGGGTTGCAACTGAGGGAGCCTTGAATACACCAAAAGATCACATTGGCACCCGCAATCCTGCTAACAATGCTGCAATCGTGCTACAACTTCCTCAAGGAACAACATTGCCAAAAGGCTTCTACGCAGAAGGGAGCAGAGGCGGCAGTCAAGCCTCTTCTCGTTCCTCATCACGTAGTCGCAACAGTTCAAGAAATTCAACTCCAGGCAGCAGTAGGGGAACTTCTCCTGCTAGAATGGCTGGCAATGGCGGTGATGCTGCTCTTGCTTTGCTGCTGCTTGACAGATTGAACCAGCTTGAGAGCAAAATGTCTGGTAAAGGCCAACAACAACAAGGCCAAACTGTCACTAAGAAATCTGCTGCTGAGGCTTCTAAGAAGCCTCGGCAAAAACGTACTGCCACTAAAGCATACAATGTAACACAAGCTTTCGGCAGACGTGGTCCAGAACAAACCCAAGGAAATTTTGGGGACCAGGAACTAATCAGACAAGGAACTGATTACAAACATTGGCCGCAAATTGCACAATTTGCCCCCAGCGCTTCAGCGTTCTTCGGAATGTCGCGCATTGGCATGGAAGTCACACCTTCGGGAACGTGGTTGACCTACACAGGTGCCATCAAATTGGATGACAAAGATCCAAATTTCAAAGATCAAGTCATTTTGCTGAATAAGCATATTGACGCATACAAAACATTCCCACCAACAGAGCCTAAAAAGGACAAAAAGAAGAAGGCTGATGAAACTCAAGCCTTACCGCAGAGACAGAAGAAACAGCAAACTGTGACTCTTCTTCCTGCTGCAGATTTGGATGATTTCTCCAAACAATTGCAACAATCCATGAGCAGTGCTGACTCAACTCAGGCCTAAACTCATGCAGACCACACAAGGCAGATGGGCTATATAAACGTTTTCGCTTTTCCGTTTACGATATATAGTCTACTCTTGTGCAGAATGAATTCTCGTAACTACATAGCACAAGTAGATGTAGTTAACTTTAATCTCACATAGCAATCTTTAATCAGTGTGTAACATTAGGGAGGACTTGAAAGAGCCACCACATTTTCACCGAGGCCACGCGGAGTACGATCGAGTGTACAGTGAACAATGCTAGGGAGAGCTGCCTATATGGAAGAGCCCTAATGTGTAAAATTAATTTTAGTAGTGCTATCCCCATGTGATTTTAATAGCTTCTTAGGAGAATGACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA']
]

'''
#compute alignment consensus
'''

consensus = []

total = 0

for seq_record in SeqIO.parse(import_settings.coordinates, "fasta"):
    _copy_count = len(dups[seq_record.description])
    seq = str(seq_record.seq).upper()
    if len (consensus) == 0:
        consensus = [{} for l in range (0, len (seq), 3)]
    total += _copy_count
    for i in range (0, len (seq), 3):
    	codon = seq[i:i+3]
    	ci = i // 3
    	if codon != "---":
            if codon not in consensus[ci]:
                consensus[ci][codon] = _copy_count
            else:
                consensus[ci][codon] += _copy_count

#for i, c in enumerate (consensus):        
#    print (i, c, file = sys.stderr)        

ref_seq = [ ]
ref_strikes = []

for i, codon_counts in enumerate(consensus):
	if len (codon_counts) > 0:
		consensus_codon_pair = max(codon_counts.items(), key=operator.itemgetter(1))
		consensus_codon = consensus_codon_pair[0]
		nucs = set (consensus_codon) - set ('-N')
		if len (nucs) == 0 or consensus_codon_pair[1] * 1000 < total:
			print ("Poor coverage (%d) or gappy consensus (%s) at position %d in consensus" % (consensus_codon_pair[1], consensus_codon_pair[0], i), file  = sys.stderr)
			consensus_codon = '---'
			ref_strikes.append (i)
	else:
		ref_strikes.append (i)
		consensus_codon = '---'
	ref_seq.append (consensus_codon)
	#print (consensus_codon, file = sys.stderr)


ref_seq = ''.join (ref_seq)

aligned_str = None
def output_record (x):
    global aligned_str 
    l = list(x)
    if len (l) == 1:
        aligned_str = l[0]

def ignore_record (x):
    pass


for s in ref_genes:
    ref_genome = s[1]
    _align_par (SeqRecord(Seq(s[1]),id=s[0]),[SeqRecord(Seq(ref_seq),id="ref")], score_matrix_,False,False,0.8, ignore_record, output_record)
    if (aligned_str is not None):
        break
               



#print (">mappped\n%s" % aligned_str.seq, file = sys.stderr)
#print (">ref\n%s" % ref_genome, file = sys.stderr)

#sys.exit (0)


ref_map       = aligned_str.seq.lstrip('-')
prefix_length = len (aligned_str.seq) - len (ref_map)
ref_map = ref_map.rstrip ('-')
suffix_length = len (aligned_str.seq) - prefix_length - len (ref_map)

if len (ref_map) % 3 > 0:
	ref_map = ref_map [0: len (ref_map) - len (ref_map) % 3]

print (prefix_length, suffix_length, len (ref_map), file = sys.stderr)

aligned_str = None

for s in ref_genes:
    ref_genome = s[1][prefix_length:prefix_length+len (ref_map)]
    _align_par (SeqRecord(Seq(ref_genome),id=s[0]),[SeqRecord(Seq(ref_seq),id="ref")], score_matrix_codon,True,False,0.5, ignore_record, output_record)
    if (aligned_str is not None):
        break

ref_map       = aligned_str.seq.lstrip('-')
prefix_length += len (aligned_str.seq) - len (ref_map)
ref_map = ref_map.rstrip ('-')

#print (">mappped\n%s" % aligned_str.seq, file = sys.stderr)
#print (">ref\n%s" % ref_genome, file = sys.stderr)

#sys.exit (0)

ref_genome_corrected = []
c = 0
i = 0
rs = 0

ref_seq_map = []
ref_codons  = []


while i < len (ref_map):
    #ref_seq_map.append (c)
    cdn = str(ref_map[i:i+3])
    ref_codon = str(ref_genome[c:c+3])
    consensus_codon = str(ref_seq[rs:rs+3])
    if consensus_codon == '---':
        while consensus_codon == '---':
            ref_seq_map.append (-2)
            rs += 3
            consensus_codon = str(ref_seq[rs:rs+3])
            ref_codons.append ('---')
        #rs -= 3
    #print (i//3, rs // 3, cdn, consensus_codon, file = sys.stderr)
    if  cdn != '---':
        if cdn == cdn.upper():
        	#print (cdn, ref_codon, file = sys.stderr)
        	ref_genome_corrected.append (ref_codon)
        	ref_codons.append (ref_codon)
        	ref_seq_map.append (c+prefix_length)
        	c += 3
        else:
            ref_codon = "".join ([ref_codon[cc] if k == k.upper() else '-' for cc,k in enumerate (cdn)])
            ref_genome_corrected.append (ref_codon)
            ref_codons.append (ref_codon)
            if ref_codon == '---':
                ref_seq_map.append (-1)
            else:
            	ref_seq_map.append (c+prefix_length)
            c += len ([k for k in cdn if k == k.upper()])
             	
        if cdn != ref_codon:
            print ("Majority difference at : %s %s (%d)" % (cdn, ref_codon, i), file = sys.stderr)                
        rs += 3
    else:
        
        ref_genome_corrected.append (ref_codon)
        c+=3
        
    i+=3
    
    #c+=3
    
while rs < len (ref_seq):
	rs += 3
	ref_seq_map.append (-2)
    
ref_genome = "".join (ref_genome_corrected)	

print (">mappped\n%s" % ref_map, file = sys.stderr)
print (">ref\n%s" % ref_genome, file = sys.stderr)
print (">consensus\n%s" % ref_seq, file = sys.stderr)

for k in ref_strikes:
	print (k, ref_seq_map[k], file = sys.stderr)

#print (ref_seq_map, "\n", len (ref_seq_map), len (ref_seq)//3, len(ref_strikes), ref_strikes, len ([ k for k in ref_seq_map if k == -2]), file = sys.stderr)


'''
rfml = len (ref_map)
ref_genome = ref_genome[len (aligned_str.seq) - rfml : -1]
ref_map = ref_map.rstrip ('-')
ref_genome = ref_genome [0:len (ref_map)]

print (">seq\n%s" % ref_map, file = sys.stderr)
print (">ref\n%s" % ref_genome, file = sys.stderr)
print (map_to_genome)
'''

'''
c       = 0
i       = 0
mef_genome_corrected = []


while i < len (ref_map):
    #ref_seq_map.append (c)
    cdn = str(ref_map[i:i+3])
    ref_codon = str(ref_genome[c:c+3])
    if  cdn != '---':
        if cdn == cdn.upper():
            ref_genome_corrected.append (ref_codon)
            c += 3
        else:
            corrected_cdn = "".join ([ref_codon[cc] if k == k.upper() else '-' for cc,k in enumerate (cdn)])
            c += len ([k for k in cdn if k == k.upper()])
            #print (cdn, corrected_cdn, file = sys.stderr)
            ref_genome_corrected.append (corrected_cdn)
        map_to_genome.append (i)
    else:
        ref_genome_corrected.append (ref_codon)
        c+=3
    i+=3
    #c+=3
    
ref_genome = "".join (ref_genome_corrected)
'''


'''

i = 0
c = 0
ref_codons = []
ref_shift  = 0
accumulator = 0

print (">seq\n%s" % ref_seq, file = sys.stderr)
print (">ref\n%s" % ref_genome, file = sys.stderr)

sys.exit (0)

while i < len (ref_seq):
    #ref_seq_map.append (c)
    if ref_seq[i:i+3] != '---':
        #print (c)
        ref_codon = ref_genome[c-ref_shift:c+3-ref_shift]
        gaps = len ([k for k in str (ref_codon) if k == '-'])
        if gaps < 3:
        	accumulator += gaps
        
        print (accumulator, ref_shift, ref_codon, file = sys.stderr)
        
        if accumulator == 3:
            ref_shift += 3
            accumulator = 0
            
        ref_codon = ref_genome[c-ref_shift:c+3-ref_shift]
        ref_codons.append  (ref_codon)
        ref_seq_map.append (map_to_genome[c//3] + aligned_str.annotations['position'])
        if ref_map[c:c+3] != ref_codon:
            print ("Majority difference at : %s %s (%d)" % (ref_map[c:c+3], ref_codon, i), file = sys.stderr)

        c += 3
    else:
        ref_seq_map.append (-1)
        ref_codons.append  ('---')
    i+=3
   
'''
   
ref_seq_map = [(k - import_settings.offset)//3 for k in ref_seq_map]

#print (ref_seq_map, file = sys.stderr)

#sys.exit (0)  

     
if ref_seq_map is None:
    raise Exception ("Misssing reference sequence for coordinate mapping")

    
#print (len(ref_seq), file = sys.stderr)
# compile the list of sites that are under selection by either MEME or FEL

def map_site_to_genome_nuc (site): #0-based nucleotide coordinate for ref genome
    #print (site, file = sys.stderr)
    rsc = ref_seq_map[site]
    if rsc >= 0:
         return rsc*3 + import_settings.offset + import_settings.frame_shift
    return -1

site_list = {}
sequences = slac["input"]["number of sequences"]
sites = slac["input"]["number of sites"]
tree = slac["input"]["trees"]["0"]
tree_object = newick_parser (tree, False)['json']
branch_lengths = {}

L = 0

variants_by_site       = [{} for k in range (sites)]
aa_variants_by_site    = [{} for k in range (sites)]
counts_by_site         = [{} for k in range (sites)]
aa_counts_by_site      = [{} for k in range (sites)]

def compute_site_MAF (site, source = None):
    variants = source[site] if source else counts_by_site [site]
    if len (variants):
        total = sum (variants.values())
        majority = (variants[ref_codons[site]] if ref_codons[site] in variants else 0) / total
        return 1-majority
    return 0

def compute_site_entropy (site, source = None):
    variants = source[site] if source else counts_by_site [site]
    total = sum (variants.values())
    return -sum ([k/total * math.log (k/total,2) for k in variants.values()])
        
    
aa_letters = set ("ACDEFGHIKLMNPQRSTVWY")

def add_annotation_to_site (site, annotation):
    gs = map_site_to_genome_nuc (site)
    if gs >= 0:
        gs = "%d" % gs
        if not gs in annotation_json:
            annotation_json [gs] = {}
        for k, v in annotation.items():
            annotation_json [gs][k] = v
    else:
        print ("Site %d is unmapped" % site, file = sys.stderr)
            
   
    
branch_name_to_short_name = {}

for b,v in slac["tested"]["0"].items():
    accession = sequence_to_accession (b)
    branch_lengths[b] = slac["branch attributes"]["0"][b]["Global MG94xREV"]
    if accession is None:
        L += slac["branch attributes"]["0"][b]["Global MG94xREV"]
        branch_name_to_short_name [b] = "N" + b[4:]
    else:
        for k in range (sites):
            branch_name_to_short_name [b] = accession_mapper[accession]
            codon = slac["branch attributes"]["0"][b]["codon"][0][k]
            if codon != '---':
                if codon not in variants_by_site[k]:
                    variants_by_site[k][codon] = 1
                    counts_by_site[k][codon] = len (dups[b])
                else:
                    variants_by_site[k][codon] += 1
                    counts_by_site[k][codon] += len (dups[b])
                aa = slac["branch attributes"]["0"][b]["amino-acid"][0][k]
                if aa in aa_letters:
                    if aa not in aa_variants_by_site[k]:
                        aa_variants_by_site[k][aa] = 1
                        aa_counts_by_site[k][aa] = len (dups[b])
                    else:
                        aa_variants_by_site[k][aa] += 1
                        aa_counts_by_site[k][aa] += len (dups[b])
                        
#print (counts_by_site, file = sys.stderr)
#print (aa_counts_by_site, file = sys.stderr)
             
tree = get_newick (tree_object, branch_name_to_short_name, branch_lengths) 
del branch_lengths              
                
if annotation_json is not None: # if this is specified, write everything out
    for k,v in enumerate (aa_counts_by_site):
        add_annotation_to_site (k, {'cdn' : counts_by_site[k], 'aa' : v})
            
        
variant_count_total = 0
variant_count_NS    = 0
        
valid_nucs = set (["A","C","G","T"])       
include_in_annotation = {}

if annotation_json is not None:
    for i, row in enumerate (slac["MLE"]["content"]["0"]["by-site"]["RESOLVED"]):
        add_annotation_to_site (i, {'SLAC' : {
                    'N' : row[3],
                    'S' : row[2],
                    'EN' : row[1],
                    'ES' : row[0],
                    'p'  : row[4],
                    'NmS' : row[7]
            }})

    
for i, row in enumerate (fel["MLE"]["content"]["0"]):

    if annotation_json is not None: # if this is specified, write everything out
        add_annotation_to_site (i, {'FEL' : {
                    'a' : row[0],
                    'b' : row[1],
                    'p' : row[4]
            }})
                        
    if row[0] + row[1] > 0:
        maf = compute_site_MAF (i)
        if maf_writer:
            ##print (variants_by_site[i], file = sys.stderr)
            total = sum (aa_counts_by_site[i].values())
            for aa, count in aa_counts_by_site[i].items():
                maf_writer.writerow ([import_settings.evolutionary_fragment, "%d" % (ref_seq_map[i] + 1), aa, "%d" % count, "%g" % (count/total), "%d" % total])
            #maf_writer.writerow ([import_settings.evolutionary_fragment, "%d" % (ref_seq_map[i] + 1), "%g" % maf, "%g" % compute_site_MAF (i, aa_counts_by_site), "%g" % compute_site_entropy (i), "%g" % compute_site_entropy (i,aa_counts_by_site), "%g" % meme["MLE"]["content"]["0"][i][6]])
        
        if evo_writer and evo_annotation:
            check_key = "%d" % (ref_seq_map[i] + import_settings.fragment_shift)
            if evo_annotation and check_key in evo_annotation:
                total = sum (counts_by_site[i].values())
                for codon, freq in counts_by_site[i].items():
                    if codon[0] in valid_nucs and codon[1] in valid_nucs and codon[2] in valid_nucs:
                        evo_writer.writerow ([import_settings.evolutionary_fragment, "%d" % (ref_seq_map[i] + 1), codon, "%g" % freq, "%g" % (freq/total), 
                                              "%g" % (evo_annotation[check_key][codon] if codon in evo_annotation[check_key] else 1e-8), max(evo_annotation[check_key].items(), key=operator.itemgetter(1))[0] ])
            
            
            
        if row[4] < import_settings.pvalue :
            site_list[i] = {'fel' : row[4], 'kind' : 'positive' if row[1] > row[0] else 'negative', 'MAF' : maf}
        else:
            if maf >= import_settings.MAF:
                site_list[i] = {'fel' : row[4],  'MAF' : maf}
        
    
for i, row in enumerate (meme["MLE"]["content"]["0"]):
    if annotation_json is not None: # if this is specified, write everything out
        add_annotation_to_site (i, {'MEME' : {
                            'p'  : row[6],
                            'a'  : row[0],
                            'b+' : row[3],
                            'w+' : row[4],
                            'b-' : row[1],
                            'w-' : row[2],
                            'br' : row [7]
                        }})

    if row[6] < import_settings.pvalue or i in site_list:
        if i in site_list:
            site_list[i]['meme'] = row[6]
            site_list[i]['meme-fraction'] = row[4]
        else:
            site_list[i] = {'meme' : row[6], 'fel' : fel["MLE"]["content"]["0"][i][4], 'meme-fraction' : row[4], 'MAF' : compute_site_MAF (i)}
            


node_parents = {}
root_node_name = None

def recurse_tree (node, last = None):  
    node_parents[node['name']] = last
    if 'children' in node:
        for n in node['children']:
            recurse_tree (n, node['name'])
            

recurse_tree (tree_object)

if annotation_json and fubar is not None:
    hpd = 0.95
    grid = fubar["grid"]
    for site, p in fubar['posterior']["0"].items():
        posteriors = [(i,v) for i,v in enumerate (p[0])]
        hdpc = sorted(posteriors, key=operator.itemgetter(1), reverse = True)
        psum = 0.
        i = 0
                
        alpha = sum ([k[0] * posteriors[i][1] for i, k in enumerate (grid)])
        beta  = sum ([k[1] * posteriors[i][1] for i, k in enumerate (grid)])
        ppp = sum ([posteriors[i][1] for i, k in enumerate (grid) if k[0]<k[1]])
        ppn = sum ([posteriors[i][1] for i, k in enumerate (grid) if k[0]>k[1]])
        non0 = sum ([posteriors[i][1] for i, k in enumerate (grid) if k[0] > 0])
        hpd0 = hpd * non0
        mean_omega  = sum ([k[1]/k[0] * posteriors[i][1] for i, k in enumerate (grid) if k[0]>0]) / non0
        
        omega = []
        
        while (psum <= hpd0):
            idx = hdpc[i][0]
            if grid[idx][0] > 0:
                psum += hdpc[i][1]
                omega.append (grid[idx][1]/grid[idx][0])
            i+=1
            
            
        add_annotation_to_site (int(site), {"fubar" : {
            "a" : alpha,
            "b" : beta,
            "p+" : ppp,
            "p-" : ppn,
            "w" : mean_omega,
            "wl" : min (omega),
            "wu" : max (omega)
        }})


def compute_JH (timing, min_date, max_date, reference_aa):
    residue_counts = {}
    mafs_by_date   = {}
    date_cutoff    = min_date + datetime.timedelta(days = 45)
    
    for residue, dates in timing.items():
        residue_counts [residue ] = 0
        for key, value in dates.items():
           #this_date =  datetime.datetime.strptime (key[0], "%Y%m%d")
           this_date = key[0]
           if this_date not in mafs_by_date:
              mafs_by_date [this_date]= {}
           if residue not in mafs_by_date[this_date]:
                mafs_by_date [this_date][residue] = 0
           mafs_by_date[this_date][residue] += value
           if parse_date_string (key[0]) <= date_cutoff:
                residue_counts[residue] += value
            
    #print (residue_counts, file = sys.stderr)
    consensus = reference_aa if reference_aa else max(residue_counts.items(), key=operator.itemgetter(1))[0]
    mafs = []
    
    for date, counts in mafs_by_date.items():
        all = sum (counts.values())
        minority = sum ([v for k, v in counts.items() if k != consensus])
        #print (all, minority, counts, [v for k, v in counts.items() if k != consensus], file = sys.stderr)
        mafs.append ([date, minority/all])
        
  
    bin_count = math.floor ((max_date - min_date).days/10 + 1.)
    values_by_bins = [[] for k in range (bin_count)]
    #print (max_date, min_date, bin_count, (max_date - min_date).days/10, file = sys.stderr)
    unique_values = set ()
    for v in mafs:
        bin = (parse_date_string(v[0])  - min_date).days // 10
        #print (v,bin, file = sys.stderr)
        values_by_bins[bin].append (v[1])
        unique_values.add (v[1])
    
    contingency_table = [[0 for k in range (bin_count)] for v in unique_values]
    value_to_index = {}
    for i,v in enumerate (sorted (list(unique_values))):
        value_to_index[v] = i
    
    for i,bin in enumerate (values_by_bins):
        for v in bin:
            contingency_table[value_to_index[v]][i] += 1
           
    value_count = len (unique_values) 
    if value_count == 1:
        return 0.
    row_sums = [sum (row) for row in contingency_table]
    column_sums = [sum ([row[j] for row in contingency_table]) for j in range (bin_count)]
    
    
    N = sum (row_sums)
    P = 0
    Q = 0
    
    r3 = sum ([k*k*k for k in row_sums])
    r2 = sum ([k*k for k in row_sums])
    c3 = sum ([k*k*k for k in column_sums])
    c2 = sum ([k*k for k in column_sums])
    
    
    varS = (2.*(N*N*N-r3-c3)+3.*(N*N-r2-c2)+5*N) / 18. + (r3-3*r2+2*N)*(c3-3*c2+2*N)/(9.*N*(N-1)*(N-2)) + (r2-N)*(c2-N)/(2.*N*(N-1))
 
   
    for i,bin in enumerate (values_by_bins):
        for v in bin:
            for j in range (i+1,bin_count):
                for e in values_by_bins[j]:
                    if e < v:
                        Q += 1
                    elif e > v:
                        P += 1
            
    Z = (P-Q) / math.sqrt (varS)            
    return Z
    
site_to_epitope = {}
    
if epitopes and annotation_json:
    this_epitope = collections.deque ()
    site_range = collections.deque ()
    for node,value in slac["branch attributes"]["0"].items():
        if node in slac["tested"]["0"] and node[0:4] != "Node":
            for site in range(sites):
               if "amino-acid" in value:
                    aa_value    = value["amino-acid"][0][site]
                    if len (aa_value) == 1:
                        if aa_value != '-':
                            if len (this_epitope) < 9:
                                this_epitope.append (aa_value)
                                site_range.append (site)
                            else:
                                this_epitope.popleft()
                                this_epitope.append (aa_value)
                                site_range.popleft()
                                site_range.append (site)
                    else:
                        this_epitope.clear()
                        site_range.clear()
                    
               if len (this_epitope) == 9:
                    str_epitope = ''.join (this_epitope)
                    if str_epitope in epitopes:
                        for si,s in enumerate (site_range):
                            if not s in site_to_epitope:
                                site_to_epitope[s] = {}
                                
                            if not str_epitope in site_to_epitope[s]:
                                site_to_epitope[s][str_epitope] = {}
                                
                            if not si in site_to_epitope[s][str_epitope]:
                                site_to_epitope[s][str_epitope][si] = 0
                            
                            site_to_epitope[s][str_epitope][si] += len (dups[node])

            
 
branch_name_to_index = {}
  
#print (set (branch_name_to_short_name.keys()) - set (meme["branch attributes"]["0"].keys()), file = sys.stderr)


for site in range(sites) if annotation_json else site_list:
    if site in site_list:
        site_list[site]['meme-branches'] = meme["MLE"]["content"]["0"][site][7]
        
        if site_list[site]['meme-branches'] > 0:
            branches_with_support = {}
            btag = "EBF site %d (partition 1)" % (site + 1)
            for branch, support in meme["branch attributes"]["0"].items ():
                if btag in support and support [btag] >= 100:
                    try:
                	    branches_with_support[branch_name_to_short_name[branch]] = support [btag] 
                    except KeyError as e:
                        pass
        
            #print ("MEME support at site %d (%d)" % (site, meme["MLE"]["content"]["0"][site][7]), file = sys.stderr)
            #print (branches_with_support, file = sys.stderr)
            site_list[site]['meme-ebf'] = branches_with_support
        
        site_list[site]['substitutions'] = [slac["MLE"]["content"]["0"]['by-site']['RESOLVED'][site][2],slac["MLE"]["content"]["0"]['by-site']['RESOLVED'][site][3]]

    evo_composition = {}
    timing      = {}
    ''' 
        for each amino acid, this will record "date" : count for when they were sampled
        timing -> 
            "residue" ->
                "date" -> count
    '''
    check_key           = "%d" % (ref_seq_map[site] + import_settings.fragment_shift)
    evo_site_annotation = evo_annotation[check_key] if evo_annotation and check_key in evo_annotation else None
    
    substitutions       = None
        
    for node,value in slac["branch attributes"]["0"].items():
        if "amino-acid" in value:
         if not node in branch_name_to_index:
            branch_name_to_index [node] = len (branch_name_to_index)
        if root_node_name is None and node not in node_parents:
            root_node_name = node
            for k in node_parents:
                if node_parents[k] == 'root':
                    node_parents[k] = node

    if site in site_list:
        labels =  [None for k in range (len (branch_name_to_index))]
        
    for node,value in slac["branch attributes"]["0"].items():
            
        if "amino-acid" in value:
        
            aa_value    = value["amino-acid"][0][site]
            codon_value = value["codon"][0][site]
            
            if len (aa_value) == 1 and evo_site_annotation:
                if codon_value not in evo_composition:
                    try:
                        evo_composition[codon_value] = {
                            "support" : evo_site_annotation[codon_value], "aa" : aa_value
                            }
                    except Exception as e:
                        evo_composition[codon_value] = {
                            "support" : 0.0, "aa" : aa_value
                            }
                            
            
            if node in date_dups:
                if aa_value not in timing:
                    timing [aa_value] = {}
                for dt, cnt in date_dups[node].items():
                    if not dt in timing [aa_value]:
                        timing [aa_value][dt] = cnt
                    else:
                        timing [aa_value][dt] += cnt
             
            if  value["nonsynonymous substitution count"][0][site] + value["synonymous substitution count"][0][site]:
                if substitutions is None:
                    substitutions = {
                        'cdn' : {},
                        'aa'  : {},
                        'lcdn' : {},
                        'laa' :  {}
                    }
                cdn_pair = "%s|%s" % (value["codon"][0][site], slac["branch attributes"]["0"][node_parents[node]]["codon"][0][site])
                aa_pair = "%s|%s" % (value["amino-acid"][0][site], slac["branch attributes"]["0"][node_parents[node]]["amino-acid"][0][site])
                if node[0:4] == "Node":
                    ks = ('cdn', 'aa')
                else:
                    ks = ('lcdn','laa')
                if cdn_pair in substitutions[ks[0]]:
                    substitutions[ks[0]][cdn_pair] += 1
                else:
                    substitutions[ks[0]][cdn_pair] = 1
                if aa_pair in substitutions[ks[1]]:
                    substitutions[ks[1]][aa_pair] += 1
                else:
                    substitutions[ks[1]][aa_pair] = 1

             
            if site in site_list:
                labels[branch_name_to_index[node]] = (aa_value,value["codon"][0][site],value["nonsynonymous substitution count"][0][site],value["synonymous substitution count"][0][site])
    
    if site in site_list:
        site_list[site]['composition'] = aa_counts_by_site[site]
        labels = {}
        labels [root_node_name] = slac["branch attributes"]["0"][root_node_name]["codon"][0][i]
        traverse_tree_in_order (tree_object,labels, slac["branch attributes"]["0"], site, None, root_node_name)
        mapped_labels = [[],[]]
        for l, v in labels.items():
            if l in branch_name_to_short_name:
                mapped_labels[0].append (branch_name_to_short_name[l])
            else:
                mapped_labels[0].append (l)
            mapped_labels[1].append (v)
        mapped_labels[1] = compress_array (mapped_labels[1])
        site_list[site]['labels'] = mapped_labels
        #compress_array(labels)
        if len (evo_composition):
            site_list[site]['evolutionary_support']     = evo_composition
            site_list[site]['evolutionary_predictions'] = evo_site_annotation
            site_list[site]['counts'] = counts_by_site[site] 
            print ("Site %d [%d] (%s)" % (site, (ref_seq_map[site] + import_settings.fragment_shift), ref_codons[site]), file = sys.stderr)
            print ("Codon\tAmino-Acid\tFrequency\tSupport", file = sys.stderr)
            all_count = sum (counts_by_site[site].values())
            for codon, support in evo_composition.items():
                codon_freq = [v for k,v in counts_by_site[site].items() if k == codon]
                if len (codon_freq):
                    print ("%s\t%s\t%.3g\t%.3g" % (codon,support["aa"],[v for k,v in counts_by_site[site].items()if k == codon][0]/all_count,support["support"]), file = sys.stderr)
            #print (site, evo_composition,aa_counts_by_site[site], file = sys.stderr)
    
    #timing_as_array = {}    
    #for aa, t in timing.items():
    #    timing_as_array [aa] = [
    #        compress_array([k[0] for k, v in timing[aa].items()]),
    #        compress_array([k[1] for k, v in timing[aa].items()]),
    #        compress_array([country_to_sub[k[1]] for k, v in timing[aa].items()]),
    #        [v for k, v in timing[aa].items()]
    #    ]
    
    #if site in site_list:
    #    site_list[site]['timing'] = timing_as_array
              
    try:
        site_AA_ref = Seq(ref_codons[site]).translate()[0]
    except Exception as e:
        site_AA_ref = None
        
    jh_z = compute_JH (timing, min_date, max_date, site_AA_ref)

    if site in site_list:
        site_list[site]['trend'] = jh_z
        site_list[site]['ref_codon'] = ref_codons[site]
        
    if annotation_json:
        add_annotation_to_site (site, {"trend" : jh_z})
        if substitutions is not None:
            add_annotation_to_site (site, {"subs" : substitutions})
        if site_to_epitope and site in site_to_epitope:
            add_annotation_to_site (site, {"hla" : site_to_epitope[site]} )
            if site in site_list:
                site_list[site]['hla'] = site_to_epitope[site]
        
    if prime and site in site_list:
        site_list[site]['prime'] = []
        prime_row = prime["MLE"]["content"]["0"][site]
        prime_headers = prime["MLE"]["headers"]
        for idx in [5,7,10,13,16,19]:
            if prime_row[idx] <= import_settings.pvalue :
               if idx == 5:
                    site_list[site]['prime'].append (['Overall', prime_row[idx], 0])
               else:
                    site_list[site]['prime'].append ([prime_headers[idx][1].replace ('p-value for non-zero effect of ',''), prime_row[idx], prime_row[idx-1]])
                    
        
        
json_out = {
    'sequences' : sequences,
    'total sequences' : sum ([len (k) for k in dups.values()]),
    'aminoacid variant sites' : [v for v in aa_variants_by_site if len (v) > 1 and len ([c for c in v.values() if c>1]) > 1],
    'all variant sites' : [v for v in variants_by_site if len (v) > 1 and len ([c for c in v.values() if c>1]) > 1],
    'duplicate_map' : mapped_dups,
    'any variation' : len ([v for v in variants_by_site if len (v) > 1]),
    'sites' : sites,
    'tree' : tree,
    'MAF' : import_settings.MAF,
    'L' : L,
    'p' : import_settings.pvalue,
#   'branch_names' : branch_name_to_index_array,
    'selection' : site_list,
    'map' : ref_seq_map,
    'dN/dS' : {
        'internal' :  meme["fits"]["Global MG94xREV"]["Rate Distributions"]["non-synonymous/synonymous rate ratio for *test*"] if "non-synonymous/synonymous rate ratio for *test*" in meme["fits"]["Global MG94xREV"]["Rate Distributions"] else None,
        'leaves'   :  meme["fits"]["Global MG94xREV"]["Rate Distributions"]["non-synonymous/synonymous rate ratio for *background*"]
    }
}

json.dump (json_out, import_settings.output, separators=(',', ':'), indent = None)
#json.dump (json_out, import_settings.output, indent = 1)

if annotation_json is not None:
    with open (import_settings.overall, "w") as ann:
        json.dump (annotation_json, ann, indent = 1)

